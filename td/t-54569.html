<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="keywords" content="report print condition, baan,baanerp,erp,forum,discussion,bulletin board" />
	<meta name="description" content="[Archive] report print condition Tools Development" />
	
	<title>report print condition [Archive]  - Baanboard.com</title>
	<link rel="stylesheet" type="text/css" href="../styles.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar"><a href="../index.html">Newbaanboard</a> &gt; <a href="../index.html">Baan Quick Support: Functional &amp; Technical</a> &gt; <a href="../index.html">Tools Development</a> &gt; report print condition</div>
<hr />
<div class="pda"></div>

<hr />

<div class="post"><div class="posttop"><div class="username">Elrodyn</div><div class="date">19th December 2008, 12:05</div></div><div class="posttext">Hello all,<br />
<br />
<br />
i'm having problem with the print condition on the LN report,<br />
<br />
<br />
i want to set the print condition on my report like this:<br />
<br />
if the field cisli205.vtal is empty the report isn't printed<br />
<br />
i already use the sprint$(cisli205.vtal) &lt;&gt;&quot;&quot; but the result is the report isn't printed at all eventhough the field isn't empty.<br />
<br />
i tried the lattr.print = false command too, but is seems not working at all.<br />
<br />
below is the script i used for the report, i customized it based from original report.<br />
<br />
|******************************************************************************<br />
|* Component	: cisli220011000   VRC B50  a  df01<br />
|* Name		: Invoices<br />
|* Author	: Jan Visser<br />
|* Date Written	: 27-03-97 [16:45]<br />
|******************************************************************************<br />
<br />
declaration:<br />
<br />
        table   ttcmcs055                                       |#116722-1.n<br />
	table	ttcemm170					|#900-140022.sn<br />
	table	ttcmcs036<br />
	table 	tcisli206<br />
|	table 	ttcmcs142					|#BRQ000813.o<br />
	table 	ttcmcs005					|#900-140022.en<br />
	table	ttcmcs041					|#Gem_INC.sn<br />
	table	ttcmcs042					|#Gem_INC.en<br />
	table	ttccom000					|#201164.sn<br />
	table	tcisli205<br />
	table	tcisli225<br />
	table	tcisli240<br />
	table	tcisli256<br />
	table	ttctax000					|#206601.n<br />
	table	ttccom114<br />
	table	ttccom115<br />
	table	ttccom130<br />
	table	ttcmcs010					|#201164.en<br />
	table	ttcmcs002					|#203578.n<br />
	table	tcisli901<br />
	table	ttccom100<br />
	table	tcisli900<br />
<br />
	domain  tcmcs.double    transfer        |* Carry forward variable<br />
<br />
	|* Variables of Payment Schedules<br />
	domain	tcdate	due.date(1)	based	|* Due date array<br />
	domain	tcamnt	dues.amount(1)	based	|* Due amount array<br />
	domain	tcamnt	dues.amount.eur(1)	based |* Due amount (Euro) array<br />
	domain	tfcmg.paym	paym.method(1)	based		|#200-153929.n<br />
<br />
								|DF78548-1.n<br />
      		long	  due.counter		|* Due counter<br />
		long	  count.dues		|* Count of due records<br />
	domain	tcmcs.int hold.nhln		|* Number of blank lines<br />
	domain	tcbool	  tax.exempt		|* is tax exempt to be used<br />
	domain	tddmth	  detail.dism(11)	|* Discount Methods<br />
        domain	tcamnt		discount			|#116722-1.sn<br />
	domain	tcmcs.str12	disc.expr	fixed<br />
	domain	tcmcs.str30	dummy.disc			|#132163.n<br />
	domain	tcmcs.str30	disc.difo<br />
	domain	tcmcs.str30	pric.difo<br />
	long		dummy.long<br />
	long		disc.array<br />
	string		dummy.string(1)				|#116722-1.en<br />
		long	sql.id<br />
		long	error<br />
	domain tcamnt 		taxable.amount			|#900-140022.sn<br />
	domain tcmcs.long 	loc.pos<br />
	domain tcccur		loc.curr<br />
		long	sql.id2<br />
		long 	error2					|#900-140022.sn<br />
	extern	domain	tcamnt		tot.due.on.amount	|#200-89095.n<br />
	extern	domain	tfcmg.paym	paym.method.on.rep	|#200-153929.n<br />
	extern	domain	tfgld.inel	tax.display<br />
|	extern	domain	tcamnt		tot.amnt		|#200-65495.n<br />
	domain		tcbool		original.invoice	|#900-134258.n<br />
	extern	domain	tcamnt		settled.amti		|#119506-1.n<br />
								|#Draft.sn<br />
	extern domain tcmcs.ctau	tax.authority(1)	based<br />
	extern domain tcdsca		tax.authority.desc(1)	based<br />
	extern domain tcfovn		tax.exempt.numb(1)	based<br />
	extern domain tcamnt		tax.base.amnt.inv(1)	based<br />
	extern domain tcpvat		tax.percent(1)		based<br />
	extern domain tcamnt		tax.amnt.inv(1)		based<br />
	extern domain tcamnt		tax.amnt.home(1,1)	based<br />
	extern domain tcccty		tax.country(1)		based<br />
	extern domain tccvat		tax.id.array(1)		based<br />
	extern	domain 	tcqsl1		lot.quantity(1) 	based<br />
	extern	domain 	tcclot		lot.code(1) 		based<br />
	extern	domain 	tcibd.sern      serial.nos(1)   	based<br />
	extern	domain 	tcqsl1		rep.lot.quantity<br />
	extern	domain 	tcclot		rep.lot.code<br />
	extern	domain 	tcibd.sern      rep.serial.nos<br />
	extern	domain  tcmcs.long	expand.array<br />
								|#800-146442.sn<br />
	extern	domain	tcmcs.long	r.row<br />
	extern	domain	tcmcs.str100	print.lot.string(1)  based<br />
	extern	domain	tcmcs.str100	rep.lot.string<br />
								|#800-146442.en<br />
	extern	domain	tcmcs.long	row.len(1)	based	|#212390.sn<br />
	extern	domain	tcmcs.st41	lot.array(1)	based<br />
		domain	tcmcs.long	def.lot(1,4)<br />
		domain	tcmcs.long	domain.length.lot<br />
		domain	tcmcs.long	row.max<br />
		domain	tcmcs.long	row.no<br />
	extern	domain	tcmcs.long	max.lot.element		|#212390.en<br />
	extern  domain  tcamnt          sum.hbai		|#219960.n<br />
	extern	domain	tcmcs.long	no.of.lines		|#212790.sn<br />
	extern	domain	tcmcs.long	max.disc.element<br />
	extern	domain	tcamnt		ldam.cisli245(1,1) based<br />
		domain		tcmcs.long	def.disc(1,4)<br />
		domain		tcmcs.long	disc.row<br />
	extern	domain		tcmcs.st45	disc.arr(1)	based<br />
	domain	tcmcs.long	domain.length.disc<br />
	extern	domain	tcmcs.long	max.disc.element	|#212790.en<br />
	extern	domain	tddmth		dism.cisli245(1,1) based|#218677.sn<br />
		domain	tddmth	  discount.method	|* Discount Method<br />
								|#218677.en<br />
	extern	domain	tcnama		itbp.nama		|#204252.sn<br />
	extern	domain	tcnamb		itbp.namb<br />
	extern	domain	tcnamc		itbp.namc<br />
	extern	domain	tcnamd		itbp.namd<br />
	extern	domain	tcname		itbp.name<br />
<br />
	 extern	domain  tcnama		cofc.nama<br />
	 extern	domain  tcnamc		cofc.namc<br />
	 extern	domain  tcname		cofc.name<br />
	 extern	domain  tcpstc		cofc.pstc<br />
<br />
	 extern	domain tcnama		pfbp.nama<br />
	 extern	domain tcname		pfbp.name<br />
	 extern	domain tcpstc		pfbp.pstc<br />
	 extern	domain tcbano		bank.acc<br />
	 extern	domain tcmcs.long	prnt.pay.slip<br />
	 extern domain tcmcs.str32	bkrn.pay.slip<br />
								|#204252.en<br />
	extern	domain tcmcs.str1	perc.sign		|#200-108356.sn<br />
	extern  domain tcmcs.str20	exempt.labl		|#200-108356.en<br />
		domain	tcmcs.long	d.convert<br />
		domain	tcmcs.long	d.temp.length<br />
		long			ret<br />
<br />
<br />
	extern domain tcmcs.long	array.index.1<br />
	extern domain tcmcs.long	array.index.2<br />
	extern domain tcbool		draft.print<br />
	extern domain tcbool		no.currencies<br />
	extern domain tcbool		d.length(5)<br />
	extern domain tcbool		tax.summary<br />
	extern domain tcbool		tax.amounts.by.authority<br />
|	extern domain tcbool		prnt			|#900-149150.n<br />
	extern domain tcdesc		dept.desc		|#900-204041.sn<br />
	extern domain tccwoc		dept			|#900-204041.en<br />
	extern domain tcmcs.str15	del.note.desc		|#201164.sn<br />
	extern domain tcmcs.str132	del.notes<br />
			string		dlyn.string(1)	based<br />
			long		no.of.rec<br />
			long		length.del.notes<br />
			long		getpos<br />
	       domain	tcbool		mem.allocated<br />
	       domain	tcyesno		o.bank<br />
	       domain	tcyesno		o.badr<br />
	extern domain tcmcs.str60	badr.1(20)		|#201164.en<br />
		domain  tcamnt          settled.txai            |#143482.sn<br />
        	domain  tcamnt          goods.net.amnt          |#143482.en<br />
		domain tcmcs.ctau	tax.ath(1)<br />
		domain tcdsca		tax.ath.desc(1)<br />
		domain tcfovn		tax.exmpt(1)<br />
		domain tcamnt		tax.base.amount(1)<br />
		domain tcpvat		tax.perc(1)<br />
		domain tcamnt		tax.amount(1)<br />
		domain tcamnt		tax.amount.home(3)<br />
		domain tcccty		tax.ctry (1)<br />
		domain tccvat		tax.code(1)<br />
		domain tcmcs.ctau	tax.athy<br />
		domain tcdsca		tax.ath.des<br />
		domain tcfovn		tax.exmt<br />
		domain tcamnt		tax.bs.amnt<br />
		domain tcpvat		tax.prc<br />
		domain tcamnt		tax.amt<br />
		domain tcccty		tax.cty<br />
		domain tccvat		tax.cde<br />
		domain tcdsca		lps.description<br />
		domain tcdsca		terms.of.paym.desc<br />
		domain tctxtn		terms.of.paym.text<br />
		domain tcdays		lps.days<br />
		domain tcdays		disc.period.1<br />
		domain tcdays		disc.period.2<br />
		domain tcdays		disc.period.3<br />
		domain tcperc		lps.percentage<br />
		domain tcperc		disc.percent.1<br />
		domain tcperc		disc.percent.2<br />
		domain tcperc		disc.percent.3<br />
		domain tcbool		print.lot.serial<br />
		domain cisli.msid	i.msid			|#201164.sn<br />
		domain tcncmp		i.ncmp<br />
		domain tcpono		i.msln<br />
		domain tcncmp		slcp.250<br />
		domain tcorno		srvo.250<br />
|		domain tcmcs.str30	invt.255		|#200-106280.so<br />
|		domain tcmcs.str30	acln.255		|#200-106280.eo<br />
			long		posno			|#200-106280.n<br />
			long		lineno<br />
		domain tcpono		lino.255<br />
		domain tcncmp		slcp.275<br />
		domain tcorno		frno.275<br />
		domain tcyesno		iniv.275<br />
		domain tcpono		pono.275<br />
		domain tcyesno		varl.275<br />
		domain tcncmp		slcp.245<br />
|		domain tcdeln		dlyn.245		|#200-106351.so<br />
|		domain whinh.shpm	shpm.245<br />
|		domain tcpono		pono.245		|#200-106351.eo<br />
		domain tcpono		sqnb.245<br />
		long	dummy.val<br />
		domain	tclang		dummy.language		|#201164.en<br />
		domain	tcyesno		sfcp.gtro		|#203578.n<br />
		domain tcmcs.long	i<br />
		domain tcmcs.long	j<br />
		domain tcmcs.long	k			|#Draft.en<br />
		domain tcmcs.long	l<br />
	extern	domain	tcbool		bp.bank.filled		|#200-107144.n<br />
	extern	domain	tfgld.ttyp	transaction.type	|#206601.sn<br />
	extern	domain	tfgld.docn	document.number		|#206601.en<br />
	extern	domain	tcamnt		gdai.discount		|#227038.sn<br />
	extern	domain	tcamnt		csai.discount<br />
	extern	domain	tcamnt		rmai.discount		|#227038.en<br />
								|#215907.sn<br />
	extern	domain	tcmcs.str60m	heco.1(20)		|* header company<br />
								|#215907.en<br />
		string st(30)					|#217767.sn		<br />
		string lot.desc(30)<br />
		string quantity.desc(30)<br />
		long length1<br />
		long length2<br />
		long label_len<br />
		long len_ret<br />
		long convert					|#217767.en<br />
		domain	tcbool	prnt.pric	  |#227642.n<br />
<br />
		domain	cisli901.fpno	fpno<br />
		domain	tcnama		itbpnama<br />
		domain	tcnamc		itbpnamc<br />
		domain	tcstr17		itbpnaam<br />
		domain	tcmcs.str25	npwp<br />
		long	rowcount<br />
	extern	domain	tcamnt		amth<br />
	extern	domain	tcamnt		txah<br />
		domain	tcamnt		total.amti<br />
		domain	tcamnt		total.amth<br />
		domain	tcratc		rate<br />
		domain	tclino		nourut<br />
	extern domain tcmcs.str50	add1<br />
extern domain tcmcs.str50	add2<br />
extern domain tcmcs.str15	npwpc<br />
	<br />
|untuk detail <br />
<br />
	extern domain tcmcs.str100	idatc<br />
	long sql1<br />
	extern domain tcdate	idatcs<br />
extern domain tcmcs.str100 	jbtnc<br />
<br />
<br />
	#include	&lt;bic_text&gt;				|#201747.n<br />
	#define TEXT.HANDLING  					|#900-132243.sn<br />
^		{<br />
^		 validate.textline()<br />
^		 }						|#900-132243.en<br />
								|#85244-1.en<br />
before.program:							|#116722-1.sn<br />
	rdi.domain(&quot;tcdisc&quot;,disc.difo,dummy.string,dummy.string,dummy.long,<br />
		   dummy.string,dummy.long)<br />
	rdi.domain(&quot;tcamnt&quot;,pric.difo,dummy.string,dummy.string,dummy.long,<br />
		   dummy.string,dummy.long)			|#116722-1.en<br />
	original.invoice = false				|#900-134258.n<br />
	mem.allocated = false					|#201164.sn<br />
	dummy.val = tcmcs.dll0005.read.company.data(get.compnr(),dummy.language)<br />
								|#201164.en<br />
	l = 1							|#800-146442.n<br />
	perc.sign = &quot;%&quot;						|#200-108356.sn<br />
	exempt.labl = form.text$(&quot;cislis2200&quot;, lattr.textlang$) |#200-108356.en<br />
	initialize.definition.qss.lot.pos()			|#212390.n<br />
	initialize.definition.qss.disc.pos()			|#212790.n<br />
	nourut = 1<br />
	<br />
<br />
|******************************************************************************<br />
|* AFTER RECEIVE DATA<br />
|******************************************************************************<br />
after.receive.data:<br />
        import(&quot;cisli245.ldam&quot;,cisli245.ldam)			|#116722-1.n<br />
	import(&quot;count.dues&quot;, count.dues)<br />
	import(&quot;settled.amti&quot;, settled.amti)			|#119506-1.n<br />
	import(&quot;detail.dism&quot;,detail.dism)<br />
	import(&quot;lps.description&quot;,lps.description)<br />
	import(&quot;terms.of.paym.desc&quot;,terms.of.paym.desc)<br />
	import(&quot;terms.of.paym.text&quot;,terms.of.paym.text)<br />
	import(&quot;lps.days&quot;,lps.days)<br />
	import(&quot;disc.period.1&quot;,disc.period.1)<br />
	import(&quot;disc.period.2&quot;,disc.period.2)<br />
	import(&quot;disc.period.3&quot;,disc.period.3)<br />
	import(&quot;lps.percentage&quot;,lps.percentage)<br />
	import(&quot;disc.percent.1&quot;,disc.percent.1)<br />
	import(&quot;disc.percent.2&quot;,disc.percent.2)<br />
	import(&quot;disc.percent.3&quot;,disc.percent.3)<br />
	import(&quot;settled.txai&quot;, settled.txai)			|#143482.sn<br />
	import(&quot;goods.net.amnt&quot;,goods.net.amnt)			|#143482.en<br />
	import(&quot;badr.1&quot;, badr.1)				|#201164.sn<br />
	import(&quot;cisli205.pfbp&quot;, cisli205.pfbp)			|#201164.en<br />
	import(&quot;cisli205.aaai&quot;, cisli205.aaai)			|#212790.sn<br />
	import(&quot;cisli205.atbi&quot;, cisli205.atbi)			|#212790.en<br />
	import(&quot;print.lot.serial&quot;, print.lot.serial)<br />
	import(&quot;bp.bank.filled&quot;, bp.bank.filled)		|#200-107144.n<br />
								|#204252.sn<br />
	import(	&quot;itbp.nama&quot;,	itbp.nama)<br />
	import(	&quot;itbp.namb&quot; ,   itbp.namb)<br />
	import(	&quot;itbp.namc&quot; ,   itbp.namc)<br />
	import(	&quot;itbp.namd&quot; ,   itbp.namd)<br />
	import(	&quot;itbp.name&quot; ,   itbp.name)<br />
	import(	&quot;cofc.nama&quot; ,   cofc.nama)<br />
	import(	&quot;cofc.namc&quot; ,   cofc.namc)<br />
	import(	&quot;cofc.name&quot; ,   cofc.name)<br />
	import(	&quot;cofc.pstc&quot; ,	cofc.pstc)<br />
        import(	&quot;pfbp.nama&quot; ,   pfbp.nama)<br />
	import(	&quot;pfbp.name&quot; ,   pfbp.name)<br />
	import(	&quot;pfbp.pstc&quot; ,   pfbp.pstc)<br />
	import(	&quot;bank.acc&quot;  ,   bank.acc)<br />
	import(	&quot;cisli205.bkrl&quot; , cisli205.bkrl)<br />
	import(	&quot;cisli205.amti&quot; , cisli205.amti)<br />
<br />
	import(	&quot;cisli205.amth&quot; , amth)<br />
	import(	&quot;cisli205.txah&quot; , txah)<br />
	import(	&quot;cisli205.rate&quot; , rate)<br />
<br />
	import(&quot;prnt.pay.slip&quot;,prnt.pay.slip)<br />
	import(&quot;bkrn.pay.slip&quot;,bkrn.pay.slip)			|#204252.en<br />
|	import(&quot;prnt&quot;,prnt)					|#900-149150.n<br />
	import(&quot;max.lot.element&quot;, max.lot.element)		|#212390.sn<br />
	import(&quot;sum.hbai&quot;, sum.hbai)				|#219960.n<br />
	import(&quot;gdai.discount&quot;, gdai.discount)			|#227038.sn<br />
	import(&quot;csai.discount&quot;, csai.discount)<br />
	import(&quot;rmai.discount&quot;, rmai.discount)			|#227038.en<br />
	if max.lot.element &lt;&gt; 0 then<br />
		alloc.mem(lot.array, 41, max.lot.element)<br />
		alloc.mem(row.len, max.lot.element)<br />
		import(&quot;lot.array&quot;, lot.array)<br />
		import(&quot;row.len&quot;, row.len)<br />
	endif							|#212390.en<br />
	import(&quot;no.of.lines&quot;, no.of.lines)			|#212790.sn<br />
	import(&quot;max.disc.element&quot;, max.disc.element)<br />
	if no.of.lines &lt;&gt; 0 then<br />
		alloc.mem(disc.arr, 45, max.disc.element)<br />
		import(&quot;disc.arr&quot;, disc.arr)<br />
|		alloc.mem(ldam.cisli245, 1, no.of.lines)	|#218677.o<br />
		alloc.mem(ldam.cisli245, no.of.lines, 11)	|#218677.n<br />
		import(&quot;ldam.cisli245&quot;, ldam.cisli245)<br />
		alloc.mem(dism.cisli245, no.of.lines, 11)	|#218677.sn<br />
		import(&quot;dism.cisli245&quot;, dism.cisli245)		|#218677.en<br />
	endif							|#212790.en<br />
	if (cisli205.nslo &gt; 0 and print.lot.serial) then<br />
|		import(&quot;expand.array&quot;,expand.array)		|#800-146442.so<br />
|		rdi.domain.string(&quot;tcclot&quot;,d.temp.length, d.convert)<br />
|		ret = alloc.mem(lot.code, d.temp.length,expand.array)<br />
|		rdi.domain.string(&quot;tcibd.sern&quot;,d.temp.length, d.convert)<br />
|		ret = alloc.mem(serial.nos, d.temp.length,expand.array)<br />
|		alloc.mem(lot.quantity,expand.array)<br />
|		import(&quot;lot.code&quot;, lot.code)<br />
|		import(&quot;serial.nos&quot;,serial.nos)<br />
|		import(&quot;lot.quantity&quot;,lot.quantity)		|#800-146442.eo<br />
		import(&quot;r.row&quot;,r.row)				|#800-146442.sn<br />
		alloc.mem(print.lot.string,100,r.row)<br />
		import(&quot;print.lot.string&quot;,print.lot.string)	|#800-146442.en<br />
		alloc.mem(lot.quantity, r.row)			|#212390.sn<br />
		import(&quot;lot.quantity&quot;, lot.quantity)		|#212390.en<br />
	endif<br />
<br />
	alloc.mem(due.date, count.dues)<br />
	alloc.mem(dues.amount, count.dues)<br />
	alloc.mem(dues.amount.eur, count.dues)			|DF78548-1.n<br />
	alloc.mem(paym.method, 3, count.dues)			|#200-153929.n<br />
	for due.counter = 1 to count.dues<br />
		get.indexed.var(parent,<br />
				&quot;due.date&quot;,<br />
				due.date(due.counter),<br />
				due.counter)<br />
		get.indexed.var(parent,<br />
				&quot;dues.amount&quot;,<br />
				dues.amount(due.counter),<br />
				due.counter)<br />
		get.indexed.var(parent,				|DF78548-1.sn<br />
				&quot;dues.amount.eur&quot;,<br />
				dues.amount.eur(due.counter),<br />
				due.counter)			|DF78548-1.en<br />
		get.indexed.var(parent,				|#200-153929.sn<br />
				&quot;paym.method&quot;,<br />
				paym.method(1, due.counter),<br />
				due.counter)			|#200-153929.en<br />
	endfor<br />
	due.counter = 0<br />
	|* cisli205.wamt is removed from Input fields and detail.lamt<br />
	|* is added to Input fields.<br />
	import(&quot;cisli205.wamt&quot;, cisli205.wamt)	|#227642.n<br />
|	tcmcs.dll0095.read.parm(&quot;tccom999&quot;)			|#Reger_OTH.o<br />
<br />
|******************************************************************************<br />
|* BEFORE FIELDS<br />
|******************************************************************************<br />
before.header.key.10:<br />
before.layout:<br />
	need(calculate.before.header.key.10.need.lines() +<br />
	     calculate.detail.need.lines())<br />
<br />
before.copy.nr.10:<br />
before.layout:							|#215907.sn<br />
	import(&quot;heco.1&quot;, heco.1)				|#215907.en<br />
after.layout:<br />
	hold.nhln = cisli120.nhln<br />
	original.invoice = true					|#900-134258.n<br />
<br />
before.copy.nr.12:<br />
before.layout:							|#215907.sn<br />
	import(&quot;heco.1&quot;, heco.1)				|#215907.en<br />
after.layout:<br />
	hold.nhln = cisli120.nhln<br />
<br />
before.copy.nr.15:<br />
before.layout:							|#130154.sn<br />
	import(&quot;heco.1&quot;, heco.1)				|#215907.n<br />
|	if original.invoice then		|#134258.n	|#135892.o<br />
	if original.invoice or copy.nr &gt; 1 then			|#135892.n<br />
		lattr.pageno = 0				|#130154.en<br />
	endif							|#900-134258.n<br />
after.layout:<br />
	hold.nhln = cisli120.nhln<br />
<br />
before.copy.nr.20:<br />
before.layout:							|#215907.sn<br />
	import(&quot;heco.1&quot;, heco.1)				|#215907.en<br />
after.layout:<br />
	hold.nhln = cisli120.nhln<br />
<br />
before.copy.nr.25:<br />
after.layout:<br />
	hold.nhln = hold.nhln - 1<br />
	if 	hold.nhln &gt; 0 then<br />
		layout.again()<br />
	endif<br />
<br />
before.copy.nr.50:<br />
before.layout:<br />
	transfer = 0<br />
	end.invoice = false<br />
	import(&quot;dept.desc&quot;,dept.desc)				|#900-204041.sn<br />
	import(&quot;dept&quot;,dept)					|#900-204041.en<br />
<br />
before.copy.nr.80:<br />
before.layout:<br />
	select cisli901.fpno:fpno<br />
	from cisli901<br />
	where cisli901.invn=:cisli205.idoc<br />
	  and cisli901.ityp=:cisli205.ityp<br />
	selectdo<br />
	endselect<br />
<br />
	select tccom100.nama:itbpnama,cisli205.idat:1<br />
	from tccom100,cisli205<br />
	where tccom100.bpid=cisli205.itbp<br />
	  and cisli205.idoc=:cisli205.idoc<br />
	  and cisli205.ityp=:cisli205.ityp<br />
	SELECTBIND(1,idatcs)<br />
	selectdo<br />
	endselect<br />
	idatc = sprintf$(&quot;%u(%02y)&quot;,idatcs)<br />
<br />
	select tccom130.namc:itbpnamc, tccom130.vatl:npwp<br />
	from tccom130,cisli205<br />
	where tccom130.cadr=cisli205.itoa<br />
	  and cisli205.idoc=:cisli205.idoc<br />
	  and cisli205.ityp=:cisli205.ityp<br />
	selectdo<br />
	endselect<br />
<br />
	select tccom130.ln01:add1,tccom130.ln02:add2<br />
	from tccom130,cisli205,tccom100<br />
	where tccom100.bpid =:cisli205.itbp<br />
	and tccom130.cadr = tccom100.cadr<br />
	selectdo<br />
	endselect<br />
<br />
	select cisli900.naam:itbpnaam, cisli900.jbtn:jbtnc<br />
	from cisli900<br />
	where cisli900.year= :idatc<br />
	selectdo<br />
	endselect<br />
npwpc = npwp<br />
<br />
<br />
<br />
<br />
before.copy.nr.90:<br />
before.layout:<br />
	transport = transfer<br />
<br />
before.line.key.40:						|#201164.sn<br />
before.layout:<br />
								|#226785.so<br />
|	import(&quot;prnt&quot;,prnt)					|#900-149150.n<br />
								|#226785.eo<br />
	if prnt then						|#900-149150.n<br />
		del.note.desc = &quot;&quot;<br />
		if tccom000.deln = tcyesno.yes then<br />
			tt.label.desc(&quot;cicisli.dlyn&quot;,ltoe(1), del.note.desc)<br />
			del.note.desc = del.note.desc &amp; &quot; &quot; &amp; &quot;:&quot;<br />
								|#200-106351.n<br />
		endif<br />
	else							|#900-149150.sn<br />
		lattr.print = false<br />
	endif							|#900-149150.en<br />
<br />
before.line.key.50:<br />
before.layout:<br />
	string.scan(header.key,&quot;%d %d&quot;,i.ncmp,i.msid)<br />
	string.scan(line.key,&quot;%d&quot;,i.msln)<br />
|	select  cisli225.dlyn					|#200-106246.o<br />
	select	cisli225.dlyn, cisli225.chtp			|#200-106246.n<br />
	from	cisli225<br />
	where	cisli225._index1 = {:i.ncmp, :i.msid, :i.msln}<br />
	as set with 1 rows<br />
	selectdo<br />
	endselect<br />
	if cisli225.chtp = cisli.chtp.goods then		|#200-106246.sn<br />
		lattr.print = true<br />
	else<br />
		lattr.print = false<br />
	endif							|#200-106246.en<br />
<br />
before.line.key.55:<br />
before.layout:<br />
|	dummy.val = 						|#200-106280.so<br />
|		tcmcs.dll0005.read.company.data(cisli205.sfcp,dummy.language)<br />
								|#200-106280.eo<br />
	del.notes = &quot;&quot;<br />
	posno	  = 0						|#200-106280.n<br />
	if not mem.allocated then<br />
	   if line = 5 then<br />
		string.scan(header.key,&quot;%d %s&quot;,slcp.250,srvo.250)<br />
								|#200-106280.so<br />
|		string.scan(line.key,&quot;%s %s %d&quot;,acln.255, invt.255, lino.255)<br />
								|#200-106280.eo<br />
		posno =    rpos(line.key, &quot; &quot;)			|#200-106280.sn<br />
		lino.255 = lval(line.key(posno+1))		|#200-106280.en<br />
<br />
		select	count(*):no.of.rec<br />
		from	cisli256<br />
		where	cisli256._index2 = {:slcp.250, cisli.ortp.serv.ord,<br />
				:srvo.250, :hold.255.acln, :hold.255.invt,<br />
				:lino.255}<br />
		as set with 1 rows<br />
		selectdo<br />
		endselect<br />
		if no.of.rec &lt;&gt; 0 then<br />
			alloc.mem(dlyn.string, no.of.rec*20)<br />
			dlyn.string = &quot;&quot;<br />
			mem.allocated = true<br />
			select	cisli256.*<br />
			from	cisli256<br />
			where	cisli256._index2 = {:slcp.250,<br />
				cisli.ortp.serv.ord, :srvo.250, :hold.255.acln,<br />
				:hold.255.invt,	:lino.255}<br />
			selectdo<br />
				dlyn.string(len(strip$(dlyn.string))+2) =<br />
					cisli256.dlyn<br />
			endselect<br />
			length.del.notes = len(strip$(dlyn.string))<br />
			if length.del.notes &gt; 130 then<br />
				getpos = rpos(dlyn.string(1;132),&quot; &quot;)<br />
				del.notes = dlyn.string(1;getpos)<br />
			else<br />
				del.notes = dlyn.string(1)<br />
			endif<br />
		endif<br />
	   endif<br />
	   if line = 8 then<br />
		string.scan(header.key,&quot;%d %s&quot;,slcp.275,frno.275)<br />
		string.scan(line.key,&quot;%d %d %d&quot;,iniv.275, pono.275, varl.275)<br />
<br />
		select	count(*):no.of.rec<br />
		from	cisli256<br />
		where	cisli256._index3 = {:slcp.275, :frno.275,<br />
				:iniv.275, :pono.275, :varl.275}<br />
		as set with 1 rows<br />
		selectdo<br />
		endselect<br />
		if no.of.rec &lt;&gt; 0 then<br />
			alloc.mem(dlyn.string, no.of.rec*20)<br />
			dlyn.string = &quot;&quot;<br />
			mem.allocated = true<br />
			select	cisli256.*<br />
			from	cisli256<br />
			where	cisli256._index3 = {:slcp.275, :frno.275,<br />
					:iniv.275, :pono.275, :varl.275}<br />
			selectdo<br />
				dlyn.string(len(strip$(dlyn.string))+2) =<br />
					cisli256.dlyn<br />
			endselect<br />
			length.del.notes = len(strip$(dlyn.string))<br />
			if length.del.notes &gt; 130 then<br />
				getpos = rpos(dlyn.string(1;132),&quot; &quot;)<br />
				del.notes = dlyn.string(1;getpos)<br />
			else<br />
				del.notes = dlyn.string(1)<br />
			endif<br />
		endif<br />
	   endif<br />
	else<br />
		length.del.notes = len(strip$(dlyn.string))<br />
		if length.del.notes &gt; 130 then<br />
			getpos = rpos(dlyn.string(1;132),&quot; &quot;)<br />
			del.notes = dlyn.string(1;getpos)<br />
		else<br />
			del.notes = dlyn.string(1)<br />
		endif<br />
	endif<br />
after.layout:<br />
	if mem.allocated then<br />
		if len(strip$(dlyn.string)) &gt; 130 then<br />
			dlyn.string = dlyn.string(getpos+1)<br />
			layout.again()<br />
		else<br />
			getpos = 0<br />
			free.mem(dlyn.string)<br />
			mem.allocated = false<br />
		endif<br />
	endif							|#201164.en<br />
<br />
|******************************************************************************<br />
|* DETAIL FIELDS<br />
|******************************************************************************<br />
detail.4:							|#106-59608.n<br />
before.layout:<br />
	disc.expr = &quot;&quot;						|#204864.n<br />
|	l =1							|#212390.o<br />
	if max.lot.element &lt;&gt; 0 then				|#212390.sn<br />
		row.no = get.row.no(cisli245.slso, cisli245.pono, cisli245.shpm,<br />
				cisli245.dlyn)<br />
		l = row.len(row.no)<br />
	endif							|#212390.en<br />
	if no.of.lines &lt;&gt; 0 then				|#212790.sn<br />
		disc.row = get.row.no.for.disc(cisli245.ortp, cisli245.koor,<br />
				cisli245.slso, cisli245.pono, cisli245.shpm,<br />
				cisli245.dlyn)<br />
	endif							|#212790.en<br />
	need(calculate.detail.need.lines())<br />
        if detail.disc(1) &lt;&gt; 0 then				|#116722-1.sn<br />
		discount  = detail.disc(1)<br />
		disc.expr = sprintf$(&quot;%@&quot;&amp;disc.difo&amp;&quot;@&quot;,discount)<br />
		disc.expr = shiftr$(disc.expr)<br />
		if disc.row &gt; 0 then				|#222281.n<br />
			discount.method = dism.cisli245(disc.row, 1)|#218677.n<br />
		endif						|#222281.n<br />
	else<br />
		if line = 4 then<br />
|			discount  = cisli245.ldam(1)		|#212790.o<br />
			if disc.row &gt; 0 then			|#212790.sn<br />
|				discount  = ldam.cisli245(1, disc.row)|#218677.o<br />
				discount  = ldam.cisli245(disc.row, 1)|#218677.n<br />
			else<br />
				discount = 0.0<br />
			endif					|#212790.en<br />
|								|#132163.so<br />
|			disc.expr = pric.difo &amp; &quot;,&quot; &amp; cisli205.ccur<br />
|			disc.expr = sprintf$(disc.expr,discount)|#132163.eo<br />
								|#132163.sn<br />
			discount = tccom.dll0001.domain.round(discount,<br />
					&quot;tcamnt&quot;, cisli205.ccur)<br />
			dummy.disc = pric.difo &amp; &quot;,&quot; &amp; cisli205.ccur<br />
			dummy.disc =<br />
				strip$(shiftl$(sprintf$(dummy.disc,discount)))<br />
			disc.expr = dummy.disc<br />
			disc.expr = shiftr$(disc.expr)		|#132163.en<br />
		endif<br />
	endif<br />
	disc.ind = 1<br />
|	if tcmcs055.gnin = tcgrnt.nett then			|#132163.so<br />
|		discount = 0<br />
|	endif							|#132163.eo<br />
								|#116722-1.en<br />
<br />
	if interest.inv then					|#Gemini_IIN.sn<br />
		if hold.key &lt;&gt; ikey and (not isspace(hold.key)) then<br />
			skip(1)<br />
		endif<br />
	endif							|#Gemini_IIN.en<br />
	|# Space was not sufficeint in layout for Print |#227642.sn<br />
	|# Condition of detail.pric. Hence, it has been moved here.<br />
	prnt.pric = true<br />
	if (line = 3 and print.price) or <br />
		(line = 5 and print.price) or<br />
		(line &lt;&gt; 3 and line &lt;&gt; 5 and line &lt;&gt; 8) then<br />
		prnt.pric = true<br />
	endif					|#227642.en<br />
	<br />
after.layout:<br />
	transfer = transfer + detail.amti - hold.235.hbai<br />
	rowcount = rowcount + 1<br />
	total.amti = total.amti + detail.amti<br />
	total.amth = total.amth + (detail.amti * rate)<br />
	nourut = nourut + 1<br />
<br />
|detail.7:					|#210140.sn	|#213183.o<br />
								|#219815.so<br />
|detail.8:							|#213183.n							|#210140.sn<br />
								|#219815.eo<br />
detail.9:							|#219815.n								<br />
before.layout:<br />
	disc.expr = &quot;&quot;<br />
	need(calculate.detail.need.lines())<br />
        if detail.disc(1) &lt;&gt; 0 then<br />
		discount  = detail.disc(1)<br />
		disc.expr = sprintf$(&quot;%@&quot;&amp;disc.difo&amp;&quot;@&quot;,discount)<br />
		disc.expr = shiftr$(disc.expr)<br />
	endif<br />
	disc.ind = 1<br />
after.layout:<br />
	transfer = transfer + detail.amti - hold.235.hbai	|#210140.en<br />
detail.42:<br />
before.layout:<br />
|	if detail.disc(disc.ind) = 0 then                       |#116722-1.so<br />
|		lattr.print = false<br />
|	else<br />
|		lattr.print = true<br />
|	endif                                                   |#116722-1.eo<br />
	disc.expr = &quot;&quot;						|#204864.n<br />
        disc.ind = disc.ind + 1					|#116722-1.sn<br />
	if disc.ind &lt;= 11 then<br />
		if detail.disc(disc.ind) &lt;&gt; 0 then<br />
			discount  = detail.disc(disc.ind)<br />
			disc.expr = sprintf$(&quot;%@&quot;&amp;disc.difo&amp;&quot;@&quot;, discount)<br />
			disc.expr = shiftr$(disc.expr)<br />
			if disc.row &gt; 0 then			|#222281.n<br />
				discount.method = dism.cisli245(disc.row, disc.ind)|#218677.n<br />
			endif					|#222281.n<br />
		else<br />
|			discount  = cisli245.ldam(disc.ind)	|#218677.o<br />
			discount  = ldam.cisli245(disc.row, disc.ind)|#218677.n<br />
|								|#132163.so<br />
|			disc.expr = pric.difo &amp; &quot;,&quot; &amp; cisli205.ccur<br />
|			disc.expr = sprintf$(disc.expr,discount)|#132163.eo<br />
								|#132163.sn<br />
			discount = tccom.dll0001.domain.round(discount,<br />
					&quot;tcamnt&quot;, cisli205.ccur)<br />
			dummy.disc = pric.difo &amp; &quot;,&quot; &amp; cisli205.ccur<br />
			dummy.disc =<br />
				strip$(shiftl$(sprintf$(dummy.disc,discount)))<br />
			disc.expr = dummy.disc<br />
			disc.expr = shiftr$(disc.expr)		|#132163.en<br />
		endif<br />
		if discount = 0 then<br />
			lattr.print = false<br />
 			for disc.array = disc.ind to 11<br />
 				if detail.disc(disc.array) &lt;&gt; 0 or<br />
				  (line = 4 and<br />
				  				|#218677.sn<br />
				  ldam.cisli245(disc.row, disc.array) &lt;&gt; 0) then<br />
				  				|#218677.en<br />
				  				|#218677.so<br />
|				   cisli245.ldam(disc.array) &lt;&gt; 0) then<br />
								|#218677.eo<br />
 					lattr.print = true<br />
 				endif<br />
 			endfor<br />
		endif<br />
	else<br />
		lattr.print = false<br />
	endif							|#116722-1.en<br />
<br />
after.layout:<br />
	if disc.ind &lt;= 11 then<br />
|		disc.ind = disc.ind + 1                         |#116722-1.o<br />
		layout.again()<br />
	endif<br />
<br />
|detail.48:							|#800-146442.so<br />
|before.layout:<br />
|	if l &lt;= expand.array then<br />
|		rep.lot.code = lot.code(1,l)<br />
|		rep.lot.quantity = lot.quantity(l)<br />
|		rep.serial.nos = serial.nos(1,l)<br />
|		lattr.print = true<br />
|	else<br />
|		lattr.print = false<br />
|	endif<br />
|<br />
|after.layout:<br />
|	if l &lt;= expand.array then<br />
|		l = l+1<br />
|		layout.again()<br />
|	endif<br />
|<br />
|detail.49:<br />
|before.layout:<br />
|	if l &lt;= expand.array then<br />
|		rep.lot.code = lot.code(1,l)<br />
|		rep.lot.quantity = lot.quantity(l)<br />
|		rep.serial.nos = serial.nos(1,l)<br />
|		lattr.print = true<br />
|	else<br />
|		lattr.print = false<br />
|	endif<br />
|<br />
|after.layout:<br />
|	if l &lt;= expand.array then<br />
|		l = l+1<br />
|		layout.again()<br />
|	endif							|#800-146442.eo<br />
<br />
detail.48:							|#800-146442.sn<br />
before.layout:<br />
								|#212390.sn<br />
	if row.no &lt;&gt; max.lot.element and max.lot.element &lt;&gt; 0 then<br />
		row.max = row.len(row.no+1)<br />
	else<br />
		row.max = r.row + 1<br />
	endif							|#212390.en<br />
|	if l &lt;= r.row	then					|#212390.o<br />
	if l &lt; row.max then					|#212390.n<br />
		rep.lot.string	= print.lot.string(1,l)<br />
		if lot.quantity(l) &lt;&gt; 0 then			|#212390.sn<br />
								|#217767.sn<br />
			tt.label.desc(&quot;cisli.lot&quot;,ttadv.cont.general, <br />
								lot.desc)<br />
			tt.label.desc(&quot;cisli.quantity&quot;,ttadv.cont.general,<br />
								 quantity.desc)<br />
			label_len = len(lot.desc)				<br />
			len_ret = rdi.domain.string(&quot;tcclot&quot; , length1 , <br />
								convert)<br />
			length2 = len(strip$(rep.lot.string))    <br />
			st = string.set$(&quot; &quot; , length1 - length2 + 2) <br />
								|#217767.en<br />
								|#217767.so<br />
|			rep.lot.string = strip$(rep.lot.string) &amp; &quot; &quot; &amp;<br />
|				str$(lot.quantity(l))<br />
								|#217767.eo<br />
							        |#217767.sn<br />
			rep.lot.string = strip$(lot.desc) &amp; &quot;:&quot; &amp; <br />
					strip$(rep.lot.string) &amp; &quot; &quot; &amp; <br />
			(st) &amp; quantity.desc &amp; &quot;:&quot; &amp; str$(lot.quantity(l))   <br />
				&amp; &quot; &quot; &amp; str$(detail.unit1)	|#217767.en<br />
				<br />
		endif						|#212390.en<br />
		|*Now , lot &amp; serial information is received in the form<br />
		|two dimensional array( this array will be already formatted in<br />
		|program script, so there is no need to format this one. we need<br />
		|to just print the array.<br />
		|*Always, lot code &amp; lot quantity will be printed in a separate<br />
		|new line.<br />
		lattr.print = true<br />
	else<br />
		lattr.print = false<br />
	endif<br />
<br />
after.layout:<br />
|	if l &lt; r.row	then					|#212390.o<br />
	if l &lt; row.max then					|#212390.n<br />
		l = l+1<br />
		layout.again()<br />
	endif<br />
<br />
detail.49:<br />
before.layout:<br />
								|#212390.sn<br />
	if row.no &lt;&gt; max.lot.element and max.lot.element &lt;&gt; 0 then<br />
		row.max = row.len(row.no+1)<br />
	else<br />
		row.max = r.row + 1<br />
	endif							|#212390.en<br />
|	if l &lt;= r.row	then					|#212390.o<br />
	if l &lt; row.max then					|#212390.n<br />
		rep.lot.string	= print.lot.string(1,l)<br />
		if lot.quantity(l) &lt;&gt; 0 then			|#212390.sn<br />
								|#217767.sn<br />
			tt.label.desc(&quot;cisli.lot&quot;,ttadv.cont.general, <br />
								lot.desc)<br />
			tt.label.desc(&quot;cisli.quantity&quot;,ttadv.cont.general,<br />
								 quantity.desc)<br />
			label_len = len(lot.desc)				<br />
			len_ret = rdi.domain.string(&quot;tcclot&quot; , length1 , <br />
								convert)<br />
			length2 = len(strip$(rep.lot.string))    <br />
			st = string.set$(&quot; &quot; , length1 - length2 + 2) <br />
								|#217767.en<br />
								|#217767.so<br />
			rep.lot.string = strip$(rep.lot.string) &amp; &quot; &quot; &amp;<br />
				str$(lot.quantity(l))<br />
								|#217767.eo<br />
								|#217767.sn<br />
			rep.lot.string = strip$(lot.desc) &amp; &quot;:&quot; &amp; <br />
					strip$(rep.lot.string) &amp; &quot; &quot; &amp; <br />
			(st) &amp; quantity.desc &amp; &quot;:&quot; &amp; str$(lot.quantity(l))   <br />
				&amp; &quot; &quot; &amp; str$(detail.unit1)	|#217767.en<br />
				<br />
		endif						|#212390.en<br />
		|*Now , lot &amp; serial information is received in the form<br />
		|two dimensional array( this array will be already formatted in<br />
		|program script, so there is no need to format this one. we need<br />
		|to just print the array.<br />
		|*Always, lot code &amp; lot quantity will be printed in a separate<br />
		|new line.<br />
		lattr.print = true<br />
	else<br />
		lattr.print = false<br />
	endif<br />
<br />
after.layout:<br />
|	if l &lt; r.row	then					|#212390.o<br />
	if l &lt; row.max then					|#212390.n<br />
		l = l+1<br />
		layout.again()<br />
	endif<br />
								|#800-146442.en<br />
detail.50:							|#201164.sn<br />
before.layout:<br />
	if tccom000.deln = tcyesno.yes and not isspace(cisli245.dlyn) then<br />
		string.scan(header.key,&quot;%d&quot;,slcp.245)<br />
								|#200-106280.so<br />
|		string.scan(line.key,&quot;%s %s %d %d&quot;,dlyn.245,shpm.245,pono.245,<br />
|				sqnb.245)			|#200-106280.eo<br />
								|#200-106351.so<br />
|								|#200-106280.sn<br />
|		string.scan(line.key,&quot;%19s %9s %d %d&quot;,dlyn.245, shpm.245,<br />
|				pono.245, sqnb.245)		|#200-106280.en<br />
								|#200-106351.eo<br />
		posno	=	0				|#200-106351.sn<br />
		posno	=	rpos(line.key, &quot; &quot;)<br />
		sqnb.245 =	lval(line.key(posno+1))		|#200-106351.en<br />
<br />
		select	cisli245.wght, cisli245.wgun, cisli240.ofad,<br />
			cisli245.cmba<br />
		from	cisli245, cisli240<br />
		where	cisli245.slcp = :slcp.245<br />
		and	cisli245.slso = :cisli245.slso<br />
		and	cisli245.ortp = :srct<br />
		and	cisli245.pono = :cisli245.pono<br />
		and	cisli245.sqnb = :sqnb.245<br />
|		and	cisli245.shpm = :shpm.245		|#200-106351.o<br />
		and	cisli245.shpm = :cisli245.shpm		|#200-106351.sn<br />
		and	cisli245.dlyn = :cisli245.dlyn		|#200-106351.en<br />
		and	cisli245.cmba refers to	cisli240<br />
		selectdo<br />
			if not eu.country(cisli240.ofad, slcp.245) then<br />
				lattr.print = false<br />
			else<br />
				lattr.print = true<br />
			endif<br />
		endselect<br />
	endif							|#201164.en<br />
<br />
detail.52:							|#BRQ000867.sn<br />
before.layout:<br />
	if hold.255.invt = tcinvt.freight then<br />
		lattr.print = true<br />
	else<br />
		lattr.print = false<br />
	endif							|#BRQ000867.en<br />
<br />
detail.54:<br />
before.layout:<br />
	if hold.255.acln &lt;&gt; save.acln and cisli120.pdtx = tcyesno.yes then<br />
		lattr.print = true<br />
	else<br />
		lattr.print = false<br />
	endif<br />
<br />
detail.56:<br />
before.layout:<br />
	if hold.255.acln &lt;&gt; save.acln and cisli120.pdtx = tcyesno.yes then<br />
		lattr.print = true<br />
	else<br />
		lattr.print = false<br />
	endif<br />
<br />
detail.65:							|#Gem_INC.sn<br />
before.layout:<br />
	if extended.cdec = tcyesno.no then<br />
		read.terms.of.delivery.desc(terms.of.del)<br />
	endif<br />
<br />
detail.75:<br />
before.layout:<br />
	if extended.ptpa = tcyesno.no then<br />
		read.point.of.title.passage(point.of.title)<br />
	endif							|#Gem_INC.en<br />
<br />
|******************************************************************************<br />
|* AFTER FIELDS<br />
|******************************************************************************<br />
after.copy.nr.1:<br />
before.layout:<br />
	|need(10)						|#900-140022.n<br />
	tax.exempt = true<br />
	i = 1							|#Draft.sn<br />
	j = 0<br />
	k = 1<br />
<br />
	import(&quot;draft.print&quot;,draft.print)<br />
	import(&quot;d.length&quot;,d.length)<br />
	import(&quot;array.index.1&quot;,array.index.1)<br />
	import(&quot;array.index.2&quot;,array.index.2)<br />
	import(&quot;no.currencies&quot;,no.currencies)<br />
	import(&quot;tax.summary&quot;,tax.summary)<br />
	import(&quot;tax.amounts.by.authority&quot;,tax.amounts.by.authority)<br />
<br />
	if draft.print then<br />
		alloc.mem(tax.country,d.length(4),array.index.2)<br />
		import(&quot;tax.country&quot;,tax.country)<br />
		alloc.mem(tax.id.array, d.length(5), array.index.2)<br />
		import(&quot;tax.id.array&quot;,tax.id.array)<br />
		if tax.amounts.by.authority then<br />
			alloc.mem(tax.authority, d.length(1), array.index.1)<br />
			import(&quot;tax.authority&quot;, tax.authority)<br />
			alloc.mem(tax.authority.desc,d.length(2), array.index.1)<br />
			import(&quot;tax.authority.desc&quot;,tax.authority.desc)<br />
			alloc.mem(tax.exempt.numb,d.length(3), array.index.1)<br />
			import(&quot;tax.exempt.numb&quot;,tax.exempt.numb)<br />
			alloc.mem(tax.base.amnt.inv, array.index.1)<br />
			import(&quot;tax.base.amnt.inv&quot;,tax.base.amnt.inv)<br />
			alloc.mem(tax.percent,array.index.1)<br />
			import(&quot;tax.percent&quot;,tax.percent)<br />
			alloc.mem(tax.amnt.inv,array.index.1)<br />
			import(&quot;tax.amnt.inv&quot;,tax.amnt.inv)<br />
			alloc.mem(tax.amnt.home,array.index.1,no.currencies)<br />
			import(&quot;tax.amnt.home&quot;,tax.amnt.home)<br />
		endif<br />
	endif							|#Draft.en<br />
								|#900-140022.sn<br />
	select tcemm170.*<br />
	from   tcemm170<br />
	where  tcemm170._index1 = {:cisli205.sfcp}<br />
	selectdo<br />
		loc.curr = tcemm170.fcua<br />
		tcemm.dll5000.position.of.hcur( cisli205.sfcp,<br />
						loc.curr,<br />
						loc.pos)<br />
	endselect<br />
	if not draft.print then<br />
		import(&quot;transaction.type&quot;, transaction.type)	|#206601.sn<br />
		import(&quot;document.number&quot;, document.number)	|#206601.en<br />
		sql.id = sql.parse(<br />
			&quot;select	cisli209.* &quot; &amp;<br />
			&quot;from	cisli209 &quot; &amp;<br />
			&quot;where	cisli209._index1 = {:cisli205.sfcp, &quot; &amp;<br />
						   &quot;:transaction.type, &quot; &amp;<br />
						   &quot;:document.number}&quot;)<br />
						   		|#900-140022.en<br />
		sql.exec(sql.id)<br />
		error = sql.fetch(sql.id)<br />
<br />
		sql.id2 = sql.parse(				|#900-140022.sn<br />
		&quot;select cisli206.txct,cisli206.txid &quot; &amp;<br />
		&quot;from cisli206 &quot;&amp;<br />
		&quot;where cisli206._index1 = { :cisli205.sfcp, &quot;&amp;<br />
				   &quot;:transaction.type, &quot;&amp;<br />
				   &quot;:document.number} &quot;)<br />
		sql.exec(sql.id2)<br />
		error2 = sql.fetch(sql.id2)			|#900-140022.en<br />
	endif<br />
<br />
	due.counter = 0						|#200-92183.sn<br />
	due.on.amount = 0<br />
	tot.due.on.amount = 0					|#200-92183.en<br />
<br />
	if cisli205.ccur= &quot;USD&quot; then skip.to (spool.pg.length -17)else<br />
		skip.to (spool.pg.length -16) endif<br />
<br />
after.copy.nr.2:<br />
before.layout:<br />
	|need(10)						|#900-140022.n<br />
	tax.exempt = true<br />
	i = 1							|#Draft.sn<br />
	j = 0<br />
	k = 1<br />
<br />
	import(&quot;draft.print&quot;,draft.print)<br />
	import(&quot;d.length&quot;,d.length)<br />
	import(&quot;array.index.1&quot;,array.index.1)<br />
	import(&quot;array.index.2&quot;,array.index.2)<br />
	import(&quot;no.currencies&quot;,no.currencies)<br />
	import(&quot;tax.summary&quot;,tax.summary)<br />
	import(&quot;tax.amounts.by.authority&quot;,tax.amounts.by.authority)<br />
<br />
	if draft.print then<br />
		alloc.mem(tax.country,d.length(4),array.index.2)<br />
		import(&quot;tax.country&quot;,tax.country)<br />
		alloc.mem(tax.id.array, d.length(5), array.index.2)<br />
		import(&quot;tax.id.array&quot;,tax.id.array)<br />
		if tax.amounts.by.authority then<br />
			alloc.mem(tax.authority, d.length(1), array.index.1)<br />
			import(&quot;tax.authority&quot;, tax.authority)<br />
			alloc.mem(tax.authority.desc,d.length(2), array.index.1)<br />
			import(&quot;tax.authority.desc&quot;,tax.authority.desc)<br />
			alloc.mem(tax.exempt.numb,d.length(3), array.index.1)<br />
			import(&quot;tax.exempt.numb&quot;,tax.exempt.numb)<br />
			alloc.mem(tax.base.amnt.inv, array.index.1)<br />
			import(&quot;tax.base.amnt.inv&quot;,tax.base.amnt.inv)<br />
			alloc.mem(tax.percent,array.index.1)<br />
			import(&quot;tax.percent&quot;,tax.percent)<br />
			alloc.mem(tax.amnt.inv,array.index.1)<br />
			import(&quot;tax.amnt.inv&quot;,tax.amnt.inv)<br />
			alloc.mem(tax.amnt.home,array.index.1,no.currencies)<br />
			import(&quot;tax.amnt.home&quot;,tax.amnt.home)<br />
		endif<br />
	endif							|#Draft.en<br />
								|#900-140022.sn<br />
	select tcemm170.*<br />
	from   tcemm170<br />
	where  tcemm170._index1 = {:cisli205.sfcp}<br />
	selectdo<br />
		loc.curr = tcemm170.fcua<br />
		tcemm.dll5000.position.of.hcur( cisli205.sfcp,<br />
						loc.curr,<br />
						loc.pos)<br />
	endselect<br />
	if not draft.print then<br />
		import(&quot;transaction.type&quot;, transaction.type)	|#206601.sn<br />
		import(&quot;document.number&quot;, document.number)	|#206601.en<br />
		sql.id = sql.parse(<br />
			&quot;select	cisli209.* &quot; &amp;<br />
			&quot;from	cisli209 &quot; &amp;<br />
			&quot;where	cisli209._index1 = {:cisli205.sfcp, &quot; &amp;<br />
						   &quot;:transaction.type, &quot; &amp;<br />
						   &quot;:document.number}&quot;)<br />
						   		|#900-140022.en<br />
		sql.exec(sql.id)<br />
		error = sql.fetch(sql.id)<br />
<br />
		sql.id2 = sql.parse(				|#900-140022.sn<br />
		&quot;select cisli206.txct,cisli206.txid &quot; &amp;<br />
		&quot;from cisli206 &quot;&amp;<br />
		&quot;where cisli206._index1 = { :cisli205.sfcp, &quot;&amp;<br />
				   &quot;:transaction.type, &quot;&amp;<br />
				   &quot;:document.number} &quot;)<br />
		sql.exec(sql.id2)<br />
		error2 = sql.fetch(sql.id2)			|#900-140022.en<br />
	endif<br />
<br />
	due.counter = 0						|#200-92183.sn<br />
	due.on.amount = 0<br />
	tot.due.on.amount = 0					|#200-92183.en<br />
<br />
	if cisli205.ccur= &quot;USD&quot; then skip.to (spool.pg.length -17)else<br />
		skip.to (spool.pg.length -15) endif<br />
<br />
<br />
after.layout:<br />
	total.amti = 0<br />
	total.amth = 0<br />
<br />
after.copy.nr.4:<br />
before.layout:<br />
	if  draft.print then					|#Draft.sn<br />
		lattr.print = tax.summary<br />
	else							|#Draft.en<br />
		lattr.print = not error<br />
	endif<br />
<br />
after.copy.nr.5:<br />
before.layout:<br />
	if  draft.print then					|#Draft.sn<br />
		if i &lt;= array.index.1 then<br />
			tax.ath(1,1) = tax.authority(1,i)<br />
			tax.athy = tax.ath(1,1)<br />
			cisli209.ctau = tax.athy<br />
			tax.ath.desc(1,1)= tax.authority.desc(1,i)<br />
			tax.ath.des = tax.ath.desc(1,1)<br />
			cisli209.dsca = tax.ath.des<br />
			tax.exmpt(1,1) = tax.exempt.numb(1,i)<br />
			tax.exmt = tax.exmpt(1,1)<br />
			cisli209.exno = tax.exmt<br />
			tax.base.amount(1) = tax.base.amnt.inv(i)<br />
			tax.bs.amnt = tax.base.amount(1)<br />
			cisli209.tbai = tax.bs.amnt<br />
			tax.perc(1) = tax.percent(i)<br />
			tax.prc = tax.perc(1)<br />
			cisli209.perc = tax.prc<br />
			tax.amount(1) = tax.amnt.inv(i)<br />
			tax.amt = tax.amount(1)<br />
			cisli209.txai = tax.amt<br />
			for j = 1 to no.currencies<br />
				tax.amount.home(j) = tax.amnt.home(i,j)<br />
			endfor<br />
			cisli209.txah = tax.amount.home<br />
			cisli209.txah(loc.pos) = tax.amount.home(loc.pos)<br />
			lattr.print = tax.summary<br />
		else<br />
			lattr.print = false<br />
		endif<br />
	else							|#Draft.en<br />
		lattr.print = not error<br />
	endif<br />
after.layout:<br />
	if draft.print then					|#Draft.sn<br />
		if i &lt;= array.index.1 then<br />
			i = i +1<br />
			layout.again()<br />
		endif<br />
	else							|#Draft.en<br />
		if not sql.fetch(sql.id) then<br />
			layout.again()<br />
		else<br />
			sql.close(sql.id)<br />
		endif<br />
	endif							|#Draft.n<br />
<br />
after.copy.nr.6:						|#900-140022.sn<br />
before.layout:<br />
	if  draft.print then					|#Draft.sn<br />
		if k &lt;= array.index.2 then<br />
			tax.ctry(1,1) = tax.country(1,k)<br />
			tax.cty = tax.ctry(1,1)<br />
			cisli206.txct = tax.cty<br />
			tax.code(1,1) = tax.id.array(1,k)<br />
			tax.cde = tax.code(1,1)<br />
			cisli206.txid = tax.cde<br />
			select tcmcs036.cvat,<br />
			       tcmcs036.ccty,<br />
			       tcmcs036.txta<br />
			from   tcmcs036<br />
			where  tcmcs036._index1 = { :tax.cty,<br />
					    	    :tax.cde}<br />
			selectdo<br />
			endselect<br />
			while tcmcs036.txta = 0			|#216654.sn<br />
				k = k +1			<br />
				if k &lt;= array.index.2 then<br />
					tax.ctry(1,1) = tax.country(1,k)<br />
					tax.cty = tax.ctry(1,1)<br />
					cisli206.txct = tax.cty<br />
					tax.code(1,1) = tax.id.array(1,k)<br />
					tax.cde = tax.code(1,1)<br />
					cisli206.txid = tax.cde<br />
					select tcmcs036.cvat,<br />
			       		       tcmcs036.ccty,<br />
       		       			       tcmcs036.txta<br />
					from   tcmcs036<br />
					where  tcmcs036._index1 = { :tax.cty,<br />
						    	    :tax.cde}<br />
					selectdo<br />
					endselect<br />
					lattr.print = tax.summary<br />
				else<br />
					lattr.print = false<br />
					break<br />
				endif					<br />
			endwhile				|#216654.en			<br />
			lattr.print = tax.summary<br />
		else<br />
			lattr.print = false<br />
		endif<br />
	else							|#Draft.en<br />
		lattr.print = not error2 and not error<br />
		select tcmcs036.cvat,tcmcs036.ccty,tcmcs036.txta<br />
		from   tcmcs036<br />
		where  tcmcs036._index1 = { :cisli206.txct,<br />
				    :cisli206.txid}<br />
		selectdo<br />
			while tcmcs036.txta = 0 		|#216654.sn<br />
				if not sql.fetch(sql.id2) then<br />
					lattr.print = not error2 and not error				<br />
					select tcmcs036.cvat,<br />
					       tcmcs036.ccty,<br />
					       tcmcs036.txta<br />
					from   tcmcs036<br />
					where  tcmcs036._index1={:cisli206.txct,<br />
			    				:cisli206.txid}<br />
					selectdo<br />
					endselect<br />
				else<br />
					sql.close(sql.id2)<br />
					lattr.print = false<br />
					break<br />
				endif<br />
			endwhile				|#216654.en		<br />
		endselect<br />
	endif							|#Draft.en<br />
<br />
after.layout:<br />
	if draft.print then					|#Draft.sn<br />
		if k &lt;= array.index.2 then<br />
			k = k +1<br />
			layout.again()<br />
		endif<br />
	else							|#Draft.en<br />
		if not sql.fetch(sql.id2) then<br />
			layout.again()<br />
		else<br />
			sql.close(sql.id2)<br />
		endif						|#900-140022.en<br />
	endif							|#Draft.n<br />
<br />
|after.copy.nr.8:						|#203578.o<br />
								|#203578.sn<br />
|* THIS LAYOUT after.copy.nr 8 HAS BEEN CHANGED TO after.copy.nr.7<br />
after.copy.nr.7:						|#203578.en<br />
before.layout:<br />
	if  draft.print then					|#Draft.sn<br />
		lattr.print = tax.summary<br />
	else							|#Draft.en<br />
		lattr.print = not error<br />
	endif<br />
<br />
|after.copy.nr.9:						|#203578.o<br />
								|#203578.sn<br />
|* THIS LAYOUT after.copy.nr 9 HAS BEEN CHANGED TO after.copy.nr.8<br />
after.copy.nr.8:						|#203578.en<br />
before.layout:<br />
	if  draft.print then					|#Draft.sn<br />
		lattr.print = tax.summary<br />
	else							|#Draft.en<br />
		lattr.print = not error<br />
	endif<br />
<br />
|after.copy.nr.10:<br />
<br />
						|#203578.o<br />
								|#203578.sn<br />
|* THIS LAYOUT after.copy.nr 10 HAS BEEN CHANGED TO after.copy.nr.9<br />
after.copy.nr.9:<br />
before.layout:<br />
	sfcp.gtro = tccom000.gtro<br />
	if cisli205.sfcp &lt;&gt; get.compnr() then<br />
		read.gtro.param(cisli205.sfcp, sfcp.gtro)<br />
	endif<br />
	import(&quot;cisli205.rddf&quot;, cisli205.rddf)			|#203578.en<br />
	cisli205.gdai = cisli205.gdai - gdai.discount		|#227038.sn<br />
	cisli205.csai = cisli205.csai - csai.discount<br />
	cisli205.dcai = cisli205.dcai - gdai.discount - csai.discount<br />
			- rmai.discount<br />
	cisli205.rmai = cisli205.rmai - rmai.discount		|#227038.en<br />
<br />
after.layout:<br />
	end.invoice = true<br />
<br />
<br />
after.copy.nr.10:						|#203578.sn<br />
before.layout:<br />
	<br />
	if sfcp.gtro = tcyesno.yes and<br />
		grand.tot.rnd.factor.defined(cisli205.ccur) then<br />
		lattr.print = true<br />
	else<br />
		lattr.print = false<br />
	endif							|#203578.en<br />
<br />
after.copy.nr.18:						|#201164.sn<br />
before.layout:<br />
|	o.bank = tcyesno.no					|#200-107145.o<br />
	o.badr = tcyesno.no					|#200-107145.n<br />
	ciint.dlltfcmg.read.payment.method.bank.and.badr(cisli205.sfcp,<br />
		cisli205.paym, o.bank, o.badr)<br />
|	if o.bank = tcyesno.yes then				|#200-107145.o<br />
								|#200-107144.so<br />
|	if o.badr = tcyesno.yes then				|#200-107145.n<br />
								|#200-107144.eo<br />
	if o.badr = tcyesno.yes and bp.bank.filled then		|#200-107144.n<br />
		lattr.print = true<br />
	else<br />
		lattr.print = false<br />
	endif<br />
<br />
after.copy.nr.19:<br />
before.layout:<br />
|	o.badr = tcyesno.no					|#200-107145.o<br />
	o.bank = tcyesno.no					|#200-107145.n<br />
	ciint.dlltfcmg.read.payment.method.bank.and.badr(cisli205.sfcp,<br />
		cisli205.paym, o.bank, o.badr)<br />
|	if o.badr = tcyesno.yes then				|#200-107145.o<br />
								|#200-107144.so<br />
|	if o.bank = tcyesno.yes then				|#200-107145.n<br />
								|#200-107144.eo<br />
	if o.bank = tcyesno.yes and bp.bank.filled then		|#200-107144.n<br />
		select	tccom114.cban, tccom114._index1<br />
		from	tccom114<br />
		where	tccom114._index1 = {:cisli205.pfbp}<br />
		and	(tccom114.cofc = :cisli205.cofc or tccom114.cofc = &quot;&quot;)<br />
		order by tccom114._index1 desc<br />
		as set with 1 rows<br />
		selectdo<br />
			select  tccom115.bano<br />
			from	tccom115<br />
			where	tccom115._index1 = {:cisli205.pfbp,<br />
							:tccom114.cban}<br />
			as set with 1 rows<br />
			selectdo<br />
			endselect<br />
		endselect<br />
		lattr.print = true<br />
	else<br />
		lattr.print = false<br />
	endif							|#201164.en<br />
<br />
|after.copy.nr.18:						|#201164.o<br />
after.copy.nr.20:						|#201164.n<br />
before.layout:<br />
		skip.to (spool.pg.length -6)<br />
	due.counter = due.counter + 1<br />
	if due.counter &lt;= count.dues then<br />
		due.on = due.date(due.counter)<br />
|		due.on.amount = dues.amount(due.counter)	|#112688.o<br />
								|#112688.sn<br />
		due.on.amount = tccom.dll0001.domain.round(<br />
						dues.amount(due.counter),<br />
						 &quot;tcamnt&quot;, cisli205.ccur)<br />
								|#112688.en<br />
		due.on.amount.eur = dues.amount.eur(due.counter) |DF78548-1.n<br />
		paym.method.on.rep = paym.method(1, due.counter)|#200-153929.n<br />
		if due.on.amount = 0 then<br />
		else<br />
			if due.on.amount.eur = 0 then		|DF78548-1.sn<br />
			   colon = &quot;&quot;<br />
			else<br />
			   colon = &quot;:&quot;<br />
			endif					|DF78548-1.en<br />
			lattr.print = true<br />
		endif<br />
								|#200-92183.sn<br />
		tot.due.on.amount = tot.due.on.amount + due.on.amount<br />
								|#200-92183.en<br />
	endif<br />
								|#200-92183.so<br />
|	tot.due.on.amount = tot.due.on.amount + due.on.amount	|#200-89095.n<br />
	lattr.print = false<br />
<br />
after.layout:<br />
	if due.counter &lt; count.dues then<br />
		layout.again()<br />
	endif<br />
	lattr.print = true<br />
<br />
after.copy.nr.22:						|#201164.n<br />
before.layout:<br />
	need(get.needed.lines.for.after.copy.nr(20))<br />
<br />
after.copy.nr.25:<br />
before.layout:<br />
	need(get.needed.lines.for.after.copy.nr(25))<br />
<br />
after.copy.nr.30:<br />
before.layout:<br />
	need(get.needed.lines.for.after.copy.nr(30))<br />
<br />
after.copy.nr.35:<br />
before.layout:<br />
	need(get.needed.lines.for.after.copy.nr(35))<br />
<br />
after.copy.nr.40:<br />
before.layout:<br />
	need(get.needed.lines.for.after.copy.nr(40))<br />
								|#119506-1.sn<br />
|	tot.amnt = cisli205.amti - cisli205.aaai - 		|#200-65495.n<br />
|		cisli205.opai - cisli205.inii - cisli205.tbii	|#200-65495.n<br />
								|#119506-1.en<br />
<br />
|after.copy.nr.45:<br />
after.copy.nr.31:<br />
before.layout:<br />
|	need(get.needed.lines.for.after.copy.nr(45))<br />
	need(get.needed.lines.for.after.copy.nr(31))<br />
<br />
after.copy.nr.70:<br />
before.layout:<br />
	need(get.needed.lines.for.after.copy.nr(70))<br />
<br />
after.copy.nr.80:						|#201747.sn<br />
before.layout:<br />
	need(get.needed.lines.for.after.copy.nr(80))<br />
								|#201747.en<br />
after.copy.nr.85:						|#800-149823.sn<br />
before.layout:<br />
|* Payment slip has to be always printed at the page bottom.<br />
|* Hence we first store number of lines yet to be printed into lineno. After<br />
|* we find the line number from which payment slip should be printed so as to be<br />
|* be printed at the end of the current page<br />
	   lineno = spool.pg.length - lattr.lineno<br />
		if lineno &gt; 21 then<br />
			lineno = lineno + lattr.lineno -23<br />
			skip.to(lineno)<br />
		else<br />
			lineno = spool.pg.length -23<br />
			skip.to(lineno)<br />
	   endif<br />
								|#800-149823.en<br />
<br />
after.header.key.1:						|#217728.sn<br />
before.layout:<br />
	if order.discount &lt;&gt; 0 then<br />
		lattr.print = true<br />
	else<br />
		lattr.print = false<br />
	endif							|#217728.en<br />
<br />
after.header.key.10:<br />
before.layout:<br />
	if cisli205.ccur=&quot;USD&quot; then skip.to (spool.pg.length -21) else<br />
	skip.to (spool.pg.length -20) endif<br />
<br />
|******************************************************************************<br />
|* FOOTER<br />
|******************************************************************************<br />
footer.10:<br />
before.layout:<br />
	transport = transfer<br />
<br />
|******************************************************************************<br />
|* TEXTS<br />
|******************************************************************************<br />
<br />
								|#120536.sn<br />
field.text:<br />
before.print:<br />
	TEXT.HANDLING<br />
<br />
field.atxt:<br />
before.print:<br />
	TEXT.HANDLING<br />
<br />
field.ftxt:<br />
before.print:<br />
	TEXT.HANDLING<br />
								|#120536.en<br />
<br />
field.dtxt:<br />
before.print:<br />
	TEXT.HANDLING<br />
<br />
field.cisli245.itxt:<br />
before.print:<br />
	TEXT.HANDLING<br />
<br />
field.cisli245.ltxt:<br />
before.print:<br />
	TEXT.HANDLING<br />
<br />
field.hold.255.actx:<br />
before.print:<br />
	TEXT.HANDLING<br />
<br />
field.hold.255.txtc:<br />
before.print:<br />
	TEXT.HANDLING<br />
<br />
|******************************************************************************<br />
|* AFTER PROGRAM<br />
|******************************************************************************<br />
after.program:<br />
	free.mem(due.date)<br />
	free.mem(dues.amount)<br />
<br />
<br />
|******************************************************************************<br />
|*				FUNCTIONS<br />
|******************************************************************************<br />
functions:<br />
<br />
|******************************************************************************<br />
|* Calculate needed lines for detail layouts<br />
|******************************************************************************<br />
function long calculate.detail.need.lines()<br />
{<br />
	long        need.detail.lines        |* Needed printlines for details<br />
<br />
	need.detail.lines = 3<br />
<br />
	|* Lines from detail 3<br />
	if not isspace(detail.desc2) then<br />
		need.detail.lines = need.detail.lines + 1<br />
	endif<br />
<br />
	|* Lines from detail 7, 30 - 56 without textlines<br />
	if not (cisli120.pdtx = tcyesno.yes and dtxt) then<br />
		|* detail lines for detail 30 - 56<br />
		on case line<br />
		case 4: if cisli245.shpm &lt;&gt; save.shpm then<br />
				need.detail.lines = need.detail.lines + 1<br />
			endif<br />
			if cisli245.pono &lt;&gt; save.pono then<br />
				need.detail.lines = need.detail.lines + 5<br />
			endif<br />
			if not isspace(cisli245.cpva) and apdx then<br />
				need.detail.lines = need.detail.lines + 1<br />
			endif<br />
			break<br />
		case 5:	if hold.255.srvo &lt;&gt; save.srvo then<br />
								|#106-59608.so<br />
|				need.detail.lines = need.detail.lines + 2<br />
								|#106-59608.eo<br />
								|#106-59608.sn<br />
				need.detail.lines = need.detail.lines + 4<br />
								|#106-59608.en<br />
			endif<br />
			if hold.255.acln &lt;&gt; save.acln then<br />
								|#106-59608.so<br />
|				need.detail.lines = need.detail.lines + 1<br />
								|#106-59608.eo<br />
								|#106-59608.sn<br />
				need.detail.lines = need.detail.lines + 3<br />
								|#106-59608.so<br />
			endif<br />
			break<br />
		endcase<br />
	endif<br />
<br />
	return(need.detail.lines +12)<br />
}<br />
<br />
|******************************************************************************<br />
|* Calculate needed lines for layout: before.header.key.10<br />
|******************************************************************************<br />
function long calculate.before.header.key.10.need.lines()<br />
{<br />
	long        need.header.lines        |* Needed printlines for Header<br />
<br />
	need.header.lines = 2<br />
	if not isspace(refb) then<br />
		need.header.lines = need.header.lines + 1<br />
	endif<br />
	if not isspace(header.dsca) then<br />
		need.header.lines = need.header.lines + 1<br />
	endif<br />
	if text and cisli120.phtx = tcyesno.yes then<br />
		need.header.lines = need.header.lines + 1<br />
	endif<br />
	if atxt and cisli120.patx = tcyesno.yes then<br />
		need.header.lines = need.header.lines + 1<br />
	endif<br />
	return(need.header.lines)<br />
}<br />
<br />
|******************************************************************************<br />
|* Calculate needed lines for layouts: after.copy.nr<br />
|******************************************************************************<br />
function long get.needed.lines.for.after.copy.nr(long after.field)<br />
{<br />
	long	counter		|* Counter for needed lines<br />
	long 	rtxt.no.lines					|#201747.n<br />
	counter = 0<br />
	rtxt.no.lines = 0					|#201747.n<br />
	on case after.field<br />
|	case 20: if cisli205.inii &lt;&gt; 0 then			|#201164.o<br />
	case 22: if cisli205.inii &lt;&gt; 0 then			|#201164.n<br />
			counter = counter + 1<br />
		 endif<br />
	case 25: if cisli205.tbii &lt;&gt; 0 then<br />
			counter = counter + 1<br />
		 endif<br />
	case 30: if cisli205.aaai &lt;&gt; 0 then<br />
			counter = counter + 1<br />
		 endif<br />
	case 35: if cisli205.opai &lt;&gt; 0 then<br />
			counter = counter + 1<br />
		 endif<br />
	case 40: if cisli205.aaai &lt;&gt; 0 or cisli205.opai &lt;&gt; 0 then<br />
			counter = counter + 3<br />
		 endif<br />
|	case 45: if cisli205.atbi &lt;&gt; 0 then<br />
	case 31: if cisli205.atbi &lt;&gt; 0 then<br />
			counter = counter + 1<br />
		 endif<br />
	case 70: if lattr.break and not isspace(cisli120.sttf) then<br />
			counter = counter + 1<br />
		 endif<br />
	case 80: if cisli120.rtxt &lt;&gt; 0  then			|#201747.sn<br />
			text.present.in.language(cisli120.rtxt,<br />
					 	language$,<br />
					 	rtxt.no.lines)<br />
			counter = counter + rtxt.no.lines<br />
		 endif						|#201747.en<br />
	endcase<br />
	return(counter)<br />
}<br />
								    |#85244-1.sn<br />
|******************************************************************************<br />
|* Validate textline<br />
|******************************************************************************<br />
|* Information:<br />
|* In the text editor it is possible to enter internal and external<br />
|* text.<br />
|* If the first line of a text starts with a '&lt;' sign the text must<br />
|* be handeled as an internal text. If the line starts '&gt;' sign the<br />
|* text must be handeled as an external text.<br />
|* Example:<br />
|* line 1:&lt; This is an internal text and must not be printed on external<br />
|* documents<br />
|* line 2:&gt; This is an external text and must be printed on interalal as<br />
|* well as on external documents<br />
|* line 3: This generic text an should be printed in all occassions.<br />
|******************************************************************************<br />
function validate.textline()<br />
{<br />
	if ( lattr.prline(1;1) = &quot;&gt;&quot; ) then<br />
		lattr.prline = lattr.prline(2)<br />
	else<br />
		if ( lattr.prline(1;1) = &quot;&lt;&quot; ) then<br />
			lattr.print = false<br />
		endif<br />
	endif<br />
}<br />
								    |#85244-1.en<br />
<br />
function void read.terms.of.delivery.desc(domain tccdec i.cdec)  |#Gem_INC.sn<br />
{<br />
	select	tcmcs041.txta,	tcmcs041.dsca<br />
	from	tcmcs041<br />
	where	tcmcs041._index1 = {:i.cdec}<br />
	as set with 1 rows<br />
	selectdo<br />
	endselect<br />
}<br />
<br />
function void read.point.of.title.passage(domain tcptpa i.ptpa)<br />
{<br />
	select tcmcs042.dsca,tcmcs042.txta<br />
	from   tcmcs042<br />
	where  tcmcs042._index1 = {:i.ptpa}<br />
	as set with 1 rows<br />
	selectdo<br />
	endselect<br />
}								|#Gem_INC.en<br />
function domain tcbool	eu.country(domain tccom.cadr i.ofad,	|#201164.sn<br />
				domain	tcncmp	slcp.245)<br />
{<br />
	select	tccom130.ccty<br />
	from	tccom130<br />
	where	tccom130._index1 = :i.ofad<br />
	selectdo<br />
	selectempty<br />
		return(false)<br />
	endselect<br />
<br />
	select 	tcmcs010.meec<br />
	from 	tcmcs010<br />
	where	tcmcs010._index1 ={:tccom130.ccty}<br />
	and	tcmcs010._compnr = :slcp.245<br />
	and	tcmcs010.meec = tcyesno.yes<br />
	as set with 1 rows<br />
	selectempty<br />
		return(false)<br />
	endselect<br />
<br />
	return(true)<br />
}								|#201164.en<br />
function domain	tcbool	grand.tot.rnd.factor.defined(		|#203578.sn<br />
				domain	tcccur	i.ccur)<br />
{<br />
	select 	tcmcs002.gtrf<br />
	from	tcmcs002<br />
	where	tcmcs002._index1 = {:i.ccur}<br />
	as set with 1 rows<br />
	selectdo<br />
		if double.cmp(tcmcs002.gtrf, 0.000000, 0.0000001) = 1 then<br />
			return(true)<br />
		else<br />
			return(false)<br />
		endif<br />
	selectempty<br />
		return(false)<br />
	endselect<br />
<br />
	return(true)<br />
}<br />
function read.gtro.param(domain	tcncmp	i.sfcp,<br />
		ref	 domain	tcyesno	o.gtro)<br />
{<br />
	select	tccom000.gtro:o.gtro<br />
	from	tccom000<br />
	where	tccom000._index1 = { 0, :i.sfcp}<br />
	as set with 1 rows<br />
	selectdo<br />
	selectempty<br />
	endselect<br />
<br />
}								|#203578.en<br />
function initialize.definition.qss.lot.pos()			|#212390.sn<br />
{<br />
	|**********************************************************************<br />
	|* This function defines the way the function qss.search should search<br />
	|* a variable in an array<br />
	|**********************************************************************<br />
<br />
	domain	tcmcs.long	domain.type<br />
	domain	tcmcs.st41		pos.str.lot<br />
<br />
	cisli.dll2089.determine.type.and.length.of.domain(<br />
							domainof(pos.str.lot),<br />
							domain.length.lot,<br />
							domain.type	)<br />
	qss.start(def.lot, 1, 1)<br />
	qss.way(def.lot, 1, QSS.UP)<br />
	qss.type(def.lot, 1, domain.type)<br />
	qss.length(def.lot, 1, domain.length.lot)<br />
}<br />
function domain tcmcs.long get.row.no( 	domain	tcorno		lot.slso,<br />
					domain  tcpono		lot.pono,<br />
					domain	whinh.shpm	lot.shpm,<br />
					domain	tcdeln		lot.dlyn)<br />
{<br />
	|**********************************************************************<br />
	|* This function returns the element number of the array which contains<br />
	|* the order no and position for the sales order and position that<br />
	|* is being printed at the moment. If The sales order and position is<br />
	|* not already used, a new element number will be assigned<br />
	|**********************************************************************<br />
<br />
	domain	tcmcs.long	element.txid<br />
	domain	tcmcs.long	counter<br />
	domain	tcmcs.st41	str.lot<br />
	domain	tcmcs.long	ret<br />
<br />
	element.txid = 0<br />
	counter = 1<br />
	str.lot = strip$(lot.slso) &amp; str$(lot.pono) &amp; lot.shpm &amp; lot.dlyn<br />
	ret	= tt.align.according.domain(str.lot, str.lot, &quot;tcmcs.st41&quot;)<br />
<br />
	element.txid = qss.search(QSS.EQUAL, str.lot, lot.array, def.lot,<br />
				  max.lot.element)<br />
<br />
	if element.txid &lt;= 0 then<br />
		max.lot.element = (max.lot.element + 1)<br />
		element.txid = max.lot.element<br />
		if max.lot.element &gt; (counter * 50) then<br />
			while( true )<br />
				if ((counter + 1)*50 &gt; max.lot.element) then<br />
					alloc.mem(lot.array,<br />
							domain.length.lot,<br />
							((counter + 1)*50))<br />
					break			|#222281.n							<br />
				else<br />
					counter = (counter + 1)<br />
				endif<br />
			endwhile<br />
		endif<br />
		lot.array(1, max.lot.element) = str.lot<br />
	endif<br />
<br />
	return(element.txid)<br />
}								|#212390.en<br />
<br />
function initialize.definition.qss.disc.pos()			|#212790.sn<br />
{<br />
	|**********************************************************************<br />
	|* This function defines the way the function qss.search should search<br />
	|* a variable in an array<br />
	|**********************************************************************<br />
<br />
	domain	tcmcs.long	domain.type<br />
	domain	tcmcs.st45	pos.str.disc<br />
	max.disc.element = 0<br />
	no.of.lines = 0<br />
<br />
	cisli.dll2089.determine.type.and.length.of.domain(<br />
							domainof(pos.str.disc),<br />
							domain.length.disc,<br />
							domain.type	)<br />
	qss.start(def.disc, 1, 1)<br />
	qss.way(def.disc, 1, QSS.UP)<br />
	qss.type(def.disc, 1, domain.type)<br />
	qss.length(def.disc, 1, domain.length.disc)<br />
	alloc.mem(disc.arr, domain.length.disc, 5)<br />
}<br />
function domain tcmcs.long get.row.no.for.disc(<br />
					domain	cisli.ortp	disc.ortp,<br />
					domain	tckoor		disc.koor,<br />
					domain	tcorno		disc.slso,<br />
					domain  tcpono		disc.pono,<br />
					domain 	whinh.shpm	disc.shpm,<br />
					domain	tcdeln		disc.dlyn)<br />
{<br />
	|**********************************************************************<br />
	|* This function returns the element number of the array which contains<br />
	|* the order no and position for the sales order and position that<br />
	|* is being printed at the moment. If The sales order and position is<br />
	|* not already used, a new element number will be assigned<br />
	|**********************************************************************<br />
<br />
	domain	tcmcs.long	element.disc<br />
	domain	tcmcs.long	counter<br />
	domain	tcmcs.st45	str.disc<br />
<br />
	element.disc = 0<br />
	counter = 1<br />
	str.disc = str$(disc.ortp) &amp; str$(disc.koor) &amp; strip$(disc.slso) &amp;<br />
			str$(disc.pono) &amp; disc.shpm &amp; disc.dlyn<br />
	ret	= tt.align.according.domain(str.disc, str.disc, &quot;tcmcs.st45&quot;)<br />
	element.disc = qss.search(QSS.EQUAL, str.disc, disc.arr, def.disc,<br />
				  max.disc.element)<br />
<br />
	if element.disc &lt;= 0 then<br />
		max.disc.element = (max.disc.element + 1)<br />
		element.disc = max.disc.element<br />
		if max.disc.element &gt; (counter * 5) then<br />
			while( true )<br />
				if ((counter + 1)*5 &gt; max.disc.element) then<br />
					alloc.mem(disc.arr,<br />
							domain.length.disc,<br />
							((counter + 1)*5))<br />
					break<br />
				else<br />
					counter = (counter + 1)<br />
				endif<br />
			endwhile<br />
		endif<br />
		disc.arr(1, max.disc.element) = str.disc<br />
	endif<br />
<br />
	return(element.disc)<br />
}								|#212790.en<br />
|****************************** END OF REPORTSCRIPT ***************************<br />
<br />
|tambahan function baru<br />
<br />
function domain tcmcs.str300m Dec.to.Hex(long dec.num)<br />
{<br />
   <br />
   domain tcmcs.str300m res.hex<br />
   <br />
     <br />
   if dec.num = 0 then return(&quot;0&quot;) endif<br />
   <br />
   res.hex = &quot;&quot;<br />
   while dec.num &lt;&gt; 0 <br />
<br />
      res.hex = Dec.to.Hex.digit(dec.num\16) &amp; res.hex  | mod<br />
      dec.num = dec.num /16 | div<br />
      <br />
   endwhile<br />
   return (res.hex)<br />
<br />
}<br />
<br />
<br />
function domain tcmcs.str1 Dec.to.Hex.digit(long dec.num)<br />
{<br />
   string res.hex(1)<br />
   <br />
   on case dec.num<br />
   <br />
      case 10: res.hex = &quot;A&quot;<br />
         break<br />
      case 11: res.hex = &quot;B&quot;<br />
         break<br />
      case 12: res.hex = &quot;C&quot;<br />
         break<br />
      case 13: res.hex = &quot;D&quot;  <br />
         break         <br />
      case 14: res.hex = &quot;E&quot;<br />
         break<br />
      case 15: res.hex = &quot;F&quot;<br />
         break<br />
      default: res.hex = str$(dec.num)<br />
         break<br />
   endcase    <br />
<br />
   return(res.hex)<br />
}</div></div><hr />


<div class="post"><div class="posttop"><div class="username">HakanT</div><div class="date">19th December 2008, 14:23</div></div><div class="posttext">Try the following:<br />
not isspace(cisli205.vtal)</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Elrodyn</div><div class="date">20th December 2008, 14:44</div></div><div class="posttext">Hi Hakant,<br />
<br />
thanks for the reply, i'll try your solution and give you feedback.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Elrodyn</div><div class="date">18th March 2009, 11:13</div></div><div class="posttext">Hello,<br />
<br />
sorry for the long respond, the problem is already solved^^<br />
<br />
i was wrong putting the condition for the lattr.print=false code, thank you</div></div><hr />



</div>
</body>
</html>