<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="keywords" content="store.* and load.*, baan,baanerp,erp,forum,discussion,bulletin board" />
	<meta name="description" content="[Archive] store.* and load.* Tools Development" />
	
	<title>store.* and load.* [Archive]  - Baanboard.com</title>
	<link rel="stylesheet" type="text/css" href="../styles.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar"><a href="../index.html">Newbaanboard</a> &gt; <a href="../index.html">Baan Quick Support: Functional &amp; Technical</a> &gt; <a href="../index.html">Tools Development</a> &gt; store.* and load.*</div>
<hr />
<div class="pda"></div>

<hr />

<div class="post"><div class="posttop"><div class="username">VishalMistry</div><div class="date">22nd February 2017, 14:17</div></div><div class="posttext">Hello Everyone,<br />
<br />
I just came to know about store.* (store.long / store.byte / store.store) and load.* functions.<br />
<br />
From the Baan manual, it indicates that it stores particular numeric value in its real machine dependent binary form in string variable.<br />
<br />
It sparked off some questions in my mind:<br />
<br />
1.Why use store.long and load.long when we can store numeric values in numeric variable straight forward way.<br />
2.Are these functions efficient in any way ? if yes then how they differ or how they are efficient technically then usual way to store and retrieve numeric values in numeric variable.<br />
<br />
<br />
Shall be grateful if somebody can explain.<br />
Any additional information will be highly appreciated.<br />
<br />
Vishal</div></div><hr />


<div class="post"><div class="posttop"><div class="username">vahdani</div><div class="date">22nd February 2017, 16:54</div></div><div class="posttext">Hello Vishal,<br />
<br />
as stated in help function is machine independent and can be used (for example) in network communications<br />
<br />
I think These functions are there if you want to communicate with an external system which uses binary data and not the usual ASCII-files.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">oirfeodent</div><div class="date">23rd February 2017, 06:13</div></div><div class="posttext">Hello Everyone,<br />
<br />
I just came to know about store.* (store.long / store.byte / store.store) and load.* functions.<br />
<br />
From the Baan manual, it indicates that it stores particular numeric value in its real machine dependent binary form in string variable.<br />
<br />
It sparked off some questions in my mind:<br />
<br />
1.Why use store.long and load.long when we can store numeric values in numeric variable straight forward way.<br />
2.Are these functions efficient in any way ? if yes then how they differ or how they are efficient technically then usual way to store and retrieve numeric values in numeric variable.<br />
<br />
<br />
Shall be grateful if somebody can explain.<br />
Any additional information will be highly appreciated.<br />
<br />
Vishal<br />
One use in practical application.<br />
1) store an integer as it is in a string array and sort that value. You will notice, &quot;    100ABC&quot; and &quot;     10ABC&quot; will give you misleading values at run time.<br />
But, if load.integer() is used to load it to the four bytes and suffixed with ABC the sorting will be consistent.<br />
<br />
Regards,</div></div><hr />


<div class="post"><div class="posttop"><div class="username">vahdani</div><div class="date">23rd February 2017, 09:37</div></div><div class="posttext">Hi oirfeodent,<br />
<br />
in your case I would have used the edit$() (http://www.baanboard.com/programmers_manual_baanerp_help_functions_formatting_io_edit) function to generate string representations of the same lenght: 00010ABC, 00100ABC, etc.<br />
<br />
This would be definitly easier to read and understand later on.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">oirfeodent</div><div class="date">24th February 2017, 08:13</div></div><div class="posttext">Hi oirfeodent,<br />
<br />
in your case I would have used the edit$() (http://www.baanboard.com/programmers_manual_baanerp_help_functions_formatting_io_edit) function to generate string representations of the same lenght: 00010ABC, 00100ABC, etc.<br />
<br />
This would be definitly easier to read and understand later on.<br />
<br />
True, edit$() looks easier if you know how your run-time data looks all the time.<br />
I've seen few times, were code is written with edit$() and at run-time... negative integer comes and the representation looks odd &quot;000-10ABC&quot;.... <br />
Off course, this can also be rectified with a properly thought off code. <br />
<br />
But, I started using store.* &amp; load.* as I dont have to write a code to pad 16 Zeros... when dealing with double. :)<br />
<br />
Regards,</div></div><hr />


<div class="post"><div class="posttop"><div class="username">BaanInOhio</div><div class="date">27th February 2017, 03:53</div></div><div class="posttext">I have used these to read and update individual fields in the internal record buffer filled by a select statement.  You can use the db.store.record and db.restore.records to save the full buffer (rcd.tdsls400, for sales orders) that includes the extended fields for locks and reference counts.  Since these records will include embedded nulls, you can't manipulate them using normal string functions since they truncate the record.  The load.* call in combination with rdi.table.column's &quot;offset&quot; field will allow pulling of variables from the buffer.  The store.* calls do the opposite, where values in the record buffer can be changed from local variables.</div></div><hr />



</div>
</body>
</html>