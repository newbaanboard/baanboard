<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="keywords" content="Problem with multi-thread processing, baan,baanerp,erp,forum,discussion,bulletin board" />
	<meta name="description" content="[Archive] Problem with multi-thread processing Tools Development" />
	
	<title>Problem with multi-thread processing [Archive]  - Baanboard.com</title>
	<link rel="stylesheet" type="text/css" href="../styles.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar"><a href="../index.html">Newbaanboard</a> &gt; <a href="../index.html">Baan Quick Support: Functional &amp; Technical</a> &gt; <a href="../index.html">Tools Development</a> &gt; Problem with multi-thread processing</div>
<hr />
<div class="pda"></div>

<hr />

<div class="post"><div class="posttop"><div class="username">gget79</div><div class="date">7th October 2008, 16:35</div></div><div class="posttext">Hi BaanFriends,  <br />
  <br />
I am using Baan Vc.  <br />
  <br />
I have made un program that it uses AFS functionality to Sales Ordes (tdsls4100m000) and this it works well when I do it in one process, but When I do it with five threads at the same time, firstly I got error 107(Record Locked), then I looked for the solution on the BaaNBoard and I found a solution to  error107 (Record Locked) then I modified the db_resource file but now I don't get the 107 error, now I get a error that say me, the row already exists.  <br />
  <br />
Anybody know that should I do?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">mark_h</div><div class="date">7th October 2008, 23:35</div></div><div class="posttext">Is it possible the row actually exists?  Is it possible that the data being processed is split or in two files being processed by different function servers.  Just wondering if the data is synchronized between the 5 processes.  For example; trying to add lines to a sales order in two different processes.  Where both could potentially decide to use the same position number.<br />
<br />
The only thing like this that I have seen is when we delete all of our GRP orders.  There are 4 of us and we run anywhere from 4 to 5 processes each.  This does generate errors, but once we get through, we reprocess those that errored out.  Not as structured as it sounds but basically the last thing we do is run just one wide open to remove the final orders.  Is it possible you track the error records and try them again as the final step?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">gget79</div><div class="date">8th October 2008, 18:05</div></div><div class="posttext">Hi Mark,  <br />
  <br />
Your solution is good, but Why is happening this?.  I know that Baan is multi-tasking and multi-user. Which argument should I take to explain this to my users?<br />
<br />
Thank you for your advice.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">mark_h</div><div class="date">8th October 2008, 20:34</div></div><div class="posttext">I can't answer that question.  Without source code I really can not tell why ours have problems like this.  I know at times I have used suspend statements to slow things up, but that kind of defeats the purpose of multi-threads.  So I am sorry, but I really do not know how to answer this for yours or our users.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">gget79</div><div class="date">8th October 2008, 20:53</div></div><div class="posttext">Hi, <br />
<br />
Thank for your time.<br />
<br />
My soruce code is:<br />
<br />
<br />
declaration:<br />
<br />
 	table	ttdsls400	| Ordenes de Venta<br />
	table	ttcmcs013	| Condiciones de pago<br />
	table	ttcmcs002	| Divisas<br />
	table	ttccom001	| Employees<br />
	table	ttcmcs011	| Recargos por atrasos<br />
	table	ttcmcs080	| Agentes de transporte<br />
	table	ttcmcs010	| Países<br />
	table	ttcmcs046	| Idiomas<br />
	table	ttcmcs041	| Condiciones de entrega<br />
	table	ttcmcs004	| Rutas<br />
	table	ttcmcs031	| Sector<br />
	table	ttcmcs045	| Zonas<br />
	table	ttuint920	| ordenes PDA fza ventas<br />
	table	ttuint100	| Parametros de Fuerza de ventas<br />
	table	ttccom110	| Partners Clientes<br />
	table	ttuint105	| Series por Ejecutivo<br />
	table	ttuint921	| Detalle ordenes venta fuerza ventas<br />
	table	ttuint003	| Parametros comunes Mabe.<br />
	table	ttcibd001	| Datos generales de artículos<br />
<br />
	extern	domain	tcmcs.str215	report.msg<br />
	extern	domain	tcyesno       	txta.yn<br />
	extern	domain	tcyesno       	flag_ok<br />
	extern	domain	tcyesno       	flag.procesar<br />
	extern	domain	tcyesno       	flag.cargar<br />
	extern	domain	tfgld.btno     flag.entry<br />
   extern	domain	tcorno        	orno.f<br />
	extern	domain	tcorno        	orno.t<br />
	extern	domain	tcmcs.str20   	ornopda.f<br />
	extern	domain	tcmcs.str20   	ornopda.t<br />
	extern	domain	tcyesno       	txta.yn<br />
   extern   domain   tcncmp         empresa<br />
   extern	domain   tcmcs.str100    arch.inp | Archivo de entrada<br />
   extern	domain   tcmcs.str100    arch.out | Archivo de Salida (errores)<br />
   extern	domain   tcrefa         refa<br />
   extern	domain   tcmcs.str6     empr<br />
   extern   domain   tcitem  item<br />
<br />
   extern   domain   tcdate   fechora  |mjc.n<br />
<br />
	domain	tcbool		   ok.proceso<br />
	domain	tcmcs.str215	error.msg<br />
	domain	tcmcs.str215	recover.msg<br />
	domain	tcorno		   ovta.orno<br />
	domain	tcpono		   ovta.pono<br />
	domain	tcpono		   ovta.sqnb<br />
	domain	tccom.bpid	   ovta.ofbp<br />
  	domain	tcmcs.str80	   path<br />
   domain	tcmcs.str80	   patho<br />
	string	num.pedido(11)<br />
	string	cli.pedido(25)<br />
	string	f.pedido(10)<br />
	string   fp.pedido(10)<br />
	string	con1(1)<br />
	string	con2(1)<br />
	string	con3(1)<br />
	string	con4(1)<br />
	string	alm.pedido(6)<br />
	string	tipo.pedido(3)<br />
	string	ase.pedido(6)<br />
   string   archivo(100)<br />
   string   archivo.reporte(100)<br />
	string   registro(400)<br />
	string   flag.cuno(30)<br />
	string   flag.crep(30)<br />
	string   flag.cwar(30)<br />
	string   flag.item(30)  |pronget01.n<br />
	string   flag.ccrs(30)<br />
	string   flag.cdel(30)<br />
	string   errores(30)<br />
	string   archivo.historia(300)<br />
   string   formatoC(5000)<br />
<br />
<br />
	long  fp,secu<br />
	long	por.act<br />
   long	ret<br />
	long  codd1  |pronget01.n<br />
	long	code0  |pronget01.n<br />
	long	code1<br />
	long	code2<br />
	long	code3<br />
	long	code4<br />
	long	code5<br />
	long  ll_ret<br />
   long  longitud<br />
	<br />
<br />
   string tiempo(10) |mjc.n<br />
<br />
	domain tcdate actual.date | NOVAGAC02.n<br />
	domain tcdate actual.date.fin | NOVAGAC03.n<br />
<br />
   |dyr1.sn<br />
   string   dat(12) | Store current date and time in format MMDDYYHHMMSS<br />
   long	out.fp      | Puntero archivo de salida<br />
   extern	domain	tcmcs.str20    que.errfile<br />
   string	err.line(250)        | Linea de errores<br />
   |dyr1.en<br />
<br />
   long genera |mjc01.n<br />
	<br />
	|pronget01.sn<br />
	extern domain tcmcs.str100 err.mesg<br />
	extern domain tcncmp ncmp.f<br />
	extern domain tcmcs.long secu.f, secu.t<br />
	|pronget01.en<br />
	<br />
	| 	Variables de ambiente<br />
	|pronget01.sn<br />
	extern domain tcmcs.long que.inicio<br />
	extern domain tcmcs.long que.fin<br />
	extern domain tcncmp		 que.cia<br />
	|pronget01.en<br />
	<br />
	|pronget02.sn<br />
	extern long    	puntero_tuint920,  puntero_tuint921<br />
	extern string	buf.ttuint920(2048), buf.ttuint921(2048)<br />
	extern long val_retu, val_retc<br />
	|pronget02.en<br />
	<br />
	|pronget02.sn<br />
	table	ttccom100	|partners<br />
	table	ttccom111	|<br />
	|pronget02.en<br />
<br />
	<br />
|************************ include section **********************************<br />
<br />
	#pragma used dll ottstpapihand<br />
	#include &lt;bic_dam&gt;<br />
   #include &lt;bic_tt&gt;       | runtime dictionary information<br />
   #pragma used dll ottdllbw     		|File Transfer and Appstart client2server<br />
   #include  &quot;ituint002&quot;<br />
   #include  &quot;ituint003&quot;<br />
|************************ program section **********************************<br />
<br />
before.program:<br />
	|pronget01.sn<br />
	err.mesg = &quot;&quot; <br />
	secu.f = 0<br />
	secu.t = 999999<br />
	|pronget01.en<br />
	<br />
	|pronget01.sn<br />
	que.inicio = lval(getenv$(&quot;SECINI&quot;))				<br />
	que.fin    =  lval(getenv$(&quot;SECFIN&quot;))<br />
	que.cia	  =  lval(getenv$(&quot;CIA&quot;))	<br />
	secu.f = que.inicio<br />
	secu.t = que.fin <br />
	ncmp.f = que.cia<br />
		<br />
	if que.inicio &gt; 0 and que.fin &gt; 0 then<br />
		if que.inicio &lt;= que.fin then<br />
			execute(cont.process)<br />
			end() <br />
		|pronget02.sn<br />
		else<br />
			end()<br />
		|pronget02.en<br />
		endif<br />
	endif<br />
	|pronget01.en<br />
|pronget01.eo<br />
|****************************** group section **********************************<br />
<br />
group.2:<br />
init.group:<br />
	get.screen.defaults()<br />
	flag.cargar = tcyesno.yes<br />
	flag.procesar = tcyesno.yes<br />
<br />
|****************************** choice section ********************************<br />
<br />
choice.cont.process:<br />
before.choice:<br />
	|pronget01.sn<br />
	if verifica.compania() then<br />
		if ncmp.f &lt;&gt; 0 then<br />
			switch.to.company(ncmp.f)<br />
			tcmcs.dll0095.read.parm(&quot;tuint003&quot;)<br />
			empresa=get.compnr() | NOVAGAC03.n<br />
			leer.parametros()<br />
			flag.cargar = tcyesno.yes<br />
			flag.procesar = tcyesno.yes<br />
			ok.indicador = true | NOVAGAC03.n<br />
		else<br />
			end()<br />
		endif<br />
	else<br />
		end()<br />
	endif<br />
	|pronget01.en<br />
<br />
   tiempo=str$(time.num())  |mjc.n<br />
<br />
	local.to.utc(date.num(),0,actual.date) | NOVAGAC02.n<br />
	local.to.utc(date.num(),86399,actual.date.fin) | NOVAGAC03.n<br />
<br />
on.choice:<br />
<br />
	ok.proceso = true<br />
	if ok.proceso then<br />
		read.main.table()<br />
	endif<br />
	end()    |dyr1.n<br />
|****************************** field section *********************************<br />
<br />
field.orno.f:<br />
when.field.changes:<br />
	orno.t = orno.f<br />
<br />
|****************************** function section ******************************<br />
<br />
functions:<br />
<br />
function read.main.table()<br />
{<br />
   empresa=get.compnr()<br />
   |Selecciono el directorio de donde se tomaran los datos del archivo de retorno<br />
   select tuint100.*<br />
   from tuint100<br />
   where tuint100._index1 ={:empresa} | NOVAGAC03.n<br />
   as set with 1 rows      |dyr.n<br />
   selectdo<br />
   endselect<br />
   flag.cargar=tcyesno.yes |pronget01.n<br />
   procesar.archivos()<br />
<br />
}<br />
<br />
<br />
function procesar.archivos()<br />
{<br />
	if flag.cargar = tcyesno.yes then<br />
		dat = dte$()<br />
		longitud = longitud + 9<br />
	endif<br />
	valid.all.data()  |Valida Cabecera<br />
	check.all.data.detalle() |Valida Detalle<br />
	validar.existencia.det_new()  |Valida si después de validaciones 	procesar.ordenes.vta()<br />
}<br />
<br />
<br />
function valid.all.data()<br />
{<br />
	err.mesg = &quot;&quot;<br />
	<br />
	|pronget01.sn<br />
	select tuint920.*<br />
|pronget02.o 	from   tuint920 for update<br />
	from   tuint920  |pronget02.n<br />
	where  tuint920._index1 inrange {:secu.f} and {:secu.t}<br />
	and    tuint920.stfz = tuint.stad.free<br />
	and    tuint920.fase = tucpe.fase.pro.subi<br />
	selectdo<br />
		lee.registro()<br />
		|pronget01.sn<br />
		select tccom110.ofbp<br />
		from tccom110<br />
		where tccom110._index1 = {:tuint920.bpid}<br />
		selectdo<br />
			code1 = 0<br />
			flag.cuno = &quot;&quot;<br />
		selectempty<br />
			code1 = 1<br />
			flag.cuno = &quot;CLIENTE: &quot; &amp; strip$(tuint920.bpid)<br />
		endselect<br />
	<br />
		select tccom001.emno<br />
		from tccom001<br />
		where tccom001._index1 = {:tuint920.crep}<br />
		selectdo<br />
			code2 = 0<br />
			flag.crep = &quot;&quot;<br />
		selectempty<br />
			code2 = 1<br />
			flag.crep = &quot;REPRESENTANTE: &quot; &amp; strip$(tuint920.crep)<br />
		endselect<br />
	<br />
		select tcmcs003.cwar<br />
		from tcmcs003<br />
		where tcmcs003._index1 = {:tuint920.cwar}<br />
		selectdo<br />
			code3 = 0<br />
			flag.cwar =&quot;&quot;<br />
		selectempty<br />
			code3 = 1<br />
			flag.cwar = &quot;ALMACEN: &quot; &amp; strip$(tuint920.cwar)<br />
		endselect<br />
		actualiza.tuint920.validaciones()  |pronget01.n<br />
	endselect |pronget01.n<br />
}<br />
<br />
|pronget01.sn<br />
function actualiza.tuint920.validaciones()<br />
{<br />
	|pronget02.sn<br />
	puntero_tuint920 = db.bind(&quot;ttuint920&quot;, buf.ttuint920)<br />
	db.columns.to.record(puntero_tuint920) <br />
	db.retry.point()<br />
		<br />
	select tuint920.*<br />
	from   tuint920 for update<br />
	where  tuint920._index1 = {:tuint920.secu}<br />
	selectdo<br />
	|pronget02.en<br />
		if code0+code1+code2+code3+code4+code5 &gt; 0 then<br />
			report.msg = &quot;ERROR: Pedido &quot; &amp; strip$(tuint920.orno) &amp; &quot; No Existe: &quot; &amp; strip$(flag.cuno) &amp; strip$(flag.crep) &amp; strip$(flag.cwar) &amp;      |dyr1.o<br />
			strip$(flag.cdel) &amp; strip$(flag.ccrs) &amp; strip$(err.mesg)<br />
			tuint920.stfz = tuint.stad.error<br />
			|pronget01.o		tuint920.stat = tdcpe.esta.error<br />
			|getsito<br />
			tuint920.fase = tucpe.fase.pro.subi<br />
		else<br />
			report.msg = &quot;&quot;<br />
			tuint920.stfz = tuint.stad.free<br />
			|pronget01.o		tuint920.stat = tdcpe.esta.libre<br />
			|getsito<br />
			tuint920.fase = tucpe.fase.pro.vali<br />
		endif<br />
		tuint920.merr = strip$(report.msg)<br />
		tuint920.erro = strip$(report.msg)<br />
		local.to.utc(date.num(), time.num(), tuint920.dtrp)<br />
		|pronget02.o 	db.retry.point()<br />
		|pronget02.o 		db.update(ttuint920,db.retry,db.skip.dupl)<br />
 		val_retu = db.update(ttuint920,DB.RETRY) |pronget02.n<br />
		val_retc =commit.transaction() |pronget02.n		<br />
	endselect |pronget02.n<br />
	<br />
	if tuint920.stfz = tuint.stad.error then<br />
		actualiza.detalles.a.error(&quot;valida&quot;)<br />
	endif<br />
	<br />
	|pronget02.sn<br />
	db.record.to.columns(puntero_tuint920) <br />
	db.unbind(puntero_tuint920)<br />
	|pronget02.en<br />
}<br />
<br />
function check.all.data.detalle()<br />
{<br />
	select tuint920.*<br />
	from   tuint920<br />
	where  tuint920._index1 inrange {:secu.f} and {:secu.t}<br />
	and    tuint920.stfz = tuint.stad.free<br />
|pronget01.o	and    tuint920.stat = tdcpe.esta.libre<br />
	and    tuint920.fase = tucpe.fase.pro.vali<br />
	selectdo<br />
		select tuint921.*<br />
|pronget02.o 		from   tuint921 for update<br />
		from   tuint921 |pronget02.n<br />
		where  tuint921._index1 = {:tuint920.orno}<br />
		selectdo<br />
			codd1 = 0<br />
			select tcibd001.*<br />
			from tcibd001<br />
			where tcibd001._index1 = {:tuint921.item}<br />
			selectdo<br />
				codd1 = 0<br />
				flag.item = &quot;&quot;<br />
			selectempty<br />
				codd1 = 1<br />
				flag.item = &quot;BLOQUEO ARTICULO&quot;<br />
			endselect<br />
			actualiza.tuint921.validaciones()<br />
		endselect<br />
	endselect<br />
}<br />
<br />
function actualiza.tuint921.validaciones()<br />
{<br />
	|pronget02.sn<br />
	puntero_tuint921 = db.bind(&quot;ttuint921&quot;, buf.ttuint921)<br />
	db.columns.to.record(puntero_tuint921) <br />
	db.retry.point()<br />
		<br />
	select tuint921.*<br />
	from   tuint921 for update<br />
	where  tuint921._index1 = {:tuint921.orno}<br />
	selectdo<br />
	|pronget02.en<br />
		if codd1 &gt; 0 then<br />
			report.msg = strip$(flag.item)<br />
			tuint921.stfz = tuint.stad.error<br />
			tuint921.stat = tdcpe.esta.error<br />
			tuint921.fase = tucpe.fase.pro.subi<br />
		else<br />
			report.msg = &quot;&quot;<br />
			tuint921.stfz = tuint.stad.free<br />
			tuint921.stat = tdcpe.esta.libre<br />
			tuint921.fase = tucpe.fase.pro.vali<br />
		endif<br />
		tuint921.merr = strip$(report.msg)<br />
		tuint921.erro = strip$(report.msg)<br />
|pronget02.o 		db.retry.point()<br />
|pronget02.o 		db.update(ttuint921,db.retry,db.skip.dupl)<br />
		val_retu = db.update(ttuint921,DB.RETRY) |pronget02.n<br />
		val_retc = commit.transaction() |pronget02.n<br />
	|pronget02.sn<br />
	endselect<br />
	<br />
	db.record.to.columns(puntero_tuint921) <br />
	db.unbind(puntero_tuint921)<br />
	|pronget02.en<br />
}<br />
<br />
|pronget01.en<br />
<br />
<br />
function lee.registro()<br />
{<br />
<br />
	empr = tuint920.empr |pronget01.n<br />
	select tuint061.*<br />
	from tuint061<br />
	|where tuint061.ncmp =:empresa NOVAGAC01.o<br />
	where tuint061._index1 = {:empresa} | NOVAGAC01.n<br />
	and tuint061.cddz=:empr<br />
	selectdo<br />
		|pronget01.sn<br />
		code0 = 0<br />
		err.mesg = &quot;&quot;<br />
		|pronget01.en<br />
	selectempty<br />
		code0 = 1 |pronget01.n<br />
		err.mesg = err.mesg &amp; &quot; |La Empresa Actual no corresponde a los datos que se encuentran en el Archivo que se desea procesar&quot;  |pronget01.n<br />
	endselect<br />
	<br />
	|Limpiamos las variables de almacenemiento<br />
	num.pedido=&quot;&quot;<br />
	cli.pedido=&quot;&quot;<br />
	f.pedido=&quot;&quot;<br />
	fp.pedido=&quot;&quot;<br />
	con1=&quot;&quot;<br />
	con2=&quot;&quot;<br />
	con3=&quot;&quot;<br />
	con4=&quot;&quot;<br />
	alm.pedido=&quot;&quot;<br />
	tipo.pedido=&quot;&quot;<br />
	ase.pedido=&quot;&quot;<br />
}<br />
<br />
function procesar.ordenes.vta()<br />
{<br />
	domain tcbool ok.error        | NOVAGAC01.n<br />
	domain tcbool ok.error.lineas | NOVAGAC01.n<br />
	<br />
	report.msg = &quot;&quot;<br />
	error.msg = &quot;&quot;<br />
	ok.proceso = true<br />
	ovta.orno = &quot;&quot;<br />
	ovta.pono = 0<br />
	ovta.sqnb = 0<br />
	ovta.ofbp = &quot;&quot;<br />
<br />
	reg.tot = 0    |dyr.n<br />
<br />
	reg.act = 0<br />
<br />
	|dyr.sn<br />
   <br />
	<br />
	|SELECT PRINCIPAL<br />
	select	tuint920.*<br />
	from	tuint920 | NOVAGAC01.n<br />
	|pronget01.sn<br />
	where  tuint920._index1 inrange {:secu.f} and {:secu.t}<br />
	and    tuint920.stfz = tuint.stad.free<br />
|pronget01.o	and    tuint920.stat = tdcpe.esta.libre<br />
	and    tuint920.fase = tucpe.fase.pro.vali<br />
	|pronget01.en<br />
	order by tuint920.crep,tuint920.secu |mjc.n<br />
	selectdo<br />
		reg.act = reg.act + 1<br />
		ok.error = false | NOVAGAC01.n<br />
<br />
		if not validar.ofbp(tuint920.bpid, error.msg) then<br />
			ok.proceso = false<br />
			report.msg = &quot;ERROR: Orden PDA: &quot; &amp; shiftl$(shiftr$(tuint920.orno)) &amp; &quot; - &quot; &amp; error.msg<br />
			continue<br />
		endif<br />
		|* Si ya se ha generado la orden de venta. No crear la cabecera<br />
		|* Nuevamente. Asiganr la variable ovta.orno el valor<br />
		|* tuint920.ornt. mabppf01<br />
<br />
		if isspace(tuint920.ornt) then<br />
			ovta.orno = &quot;&quot;<br />
			if not crear.cabecera.ovta(ovta.orno, error.msg) then<br />
				ok.proceso = false<br />
				report.msg = &quot;ERROR: Pedido &quot; &amp; tuint920.orno &amp; error.msg<br />
				tuint920.merr = report.msg<br />
				tuint920.stfz = tuint.stad.error       |dyr1.n<br />
				tuint920.erro = report.msg |pronget01.n<br />
|pronget01.o				tuint920.stat = tdcpe.esta.error |pronget01.n<br />
				actualiza.detalles.a.error(&quot;cabecera&quot;) |pronget01.n<br />
				|getsito<br />
				tuint920.fase = tucpe.fase.pro.subi |pronget01.n<br />
				ok.error = true | NOVAGAC01.n<br />
			else<br />
				report.msg = &quot;Orden PDA &quot; &amp; shiftl$(shiftr$(tuint920.orno)) &amp; &quot; - &quot; &amp; &quot;MENSAJE: Se ha creado la orden de venta &quot; &amp;<br />
					     str$(ovta.orno) &amp; &quot; cliente &quot; &amp; tuint920.bpid<br />
				tuint920.ornt = str$(ovta.orno)<br />
				tuint920.merr = report.msg<br />
				tuint920.erro = &quot;&quot; |pronget01.n<br />
|pronget01.o				tuint920.stat = tdcpe.esta.exito |pronget01.n<br />
				|getsito<br />
				tuint920.fase = tucpe.fase.pro.ovta |pronget01.n<br />
			endif<br />
			| NOVAGAC01.sn<br />
			|pronget02.sn<br />
			puntero_tuint920 = db.bind(&quot;ttuint920&quot;, buf.ttuint920)<br />
			db.columns.to.record(puntero_tuint920) <br />
			|pronget02.en<br />
			db.retry.point()<br />
			select tuint920.*<br />
			from tuint920 for update<br />
			where tuint920._index2 = {:tuint920.orno} | NOVAGAC03.n<br />
			selectdo<br />
				if ok.error then<br />
					tuint920.merr = report.msg<br />
					tuint920.erro = report.msg |pronget01.n<br />
|pronget01.o					tuint920.stat = tdcpe.esta.error |pronget01.n<br />
					|getsito<br />
					tuint920.fase = tucpe.fase.pro.subi |pronget01.n<br />
					tuint920.stfz = tuint.stad.error<br />
				else<br />
					tuint920.ornt = str$(ovta.orno)<br />
					tuint920.merr = report.msg<br />
					tuint920.erro = &quot;&quot; |pronget01.n<br />
|pronget01.o					tuint920.stat = tdcpe.esta.exito |pronget01.n<br />
					|getsito<br />
					tuint920.fase = tucpe.fase.pro.ovta |pronget01.n<br />
				endif<br />
 				val_retu = db.update(ttuint920, DB.RETRY)<br />
				val_retc = commit.transaction()<br />
			endselect<br />
			|pronget02.sn<br />
			db.record.to.columns(puntero_tuint920) <br />
			db.unbind(puntero_tuint920)<br />
			|pronget02.en<br />
			| NOVAGAC01.en<br />
		else<br />
			ovta.orno = tuint920.ornt<br />
			revisa.bloqueo.aplicacion() | NOVAGAC04.n <br />
		endif<br />
		| NOVAGAC01.sn<br />
		if ok.error then<br />
			| Si hubo error se debe regresar y no grabar las lineas de esta<br />
			| Orden<br />
			continue<br />
		endif<br />
		| NOVAGAC01.en<br />
<br />
		rec.linea = 0     |dyr.n<br />
		ovta.ofbp = tuint920.bpid<br />
		ok.error.lineas = false | NOVAGAC01.n<br />
		select	tuint921.*<br />
		from	tuint921  | NOVAGAC01.n<br />
		where	tuint921._index1 = { :tuint920.orno }<br />
		|pronget01.sn<br />
		and    tuint921.stfz = tuint.stad.free<br />
		and    tuint921.stat = tdcpe.esta.libre<br />
		and    tuint921.fase = tucpe.fase.pro.vali<br />
		|pronget01.en<br />
|pronget02.o 		order by tuint921.orno, tuint921.nuli     |dyr.n<br />
		order by tuint921._index1     |pronget02.n<br />
		selectdo<br />
			reg.tot = reg.tot + 1<br />
			rec.linea = rec.linea + 1      |dyr.n<br />
			if not crear.linea.ovta(ovta.orno, ovta.pono, ovta.sqnb, error.msg) then<br />
				ok.proceso = false<br />
				ok.error.lineas = true | NOVAGAC01.n<br />
				report.msg = &quot;ERROR: Pedido &quot; &amp; strip$(shiftl$(tuint921.orno)) &amp;<br />
				     &quot;/&quot; &amp; strip$(shiftl$(str$(tuint921.item))) &amp;<br />
				     &quot;, No se pudo crear linea O/V &quot; &amp; strip$(shiftl$(str$(ovta.orno))) &amp;<br />
				     &quot; : &quot; &amp; error.msg<br />
				tuint921.merr = &quot;O/V : &quot; &amp; strip$(shiftl$(str$(ovta.orno))) &amp; error.msg<br />
				tuint921.stfz = tuint.stad.error<br />
				tuint921.erro = &quot;O/V : &quot; &amp; strip$(shiftl$(str$(ovta.orno))) &amp; error.msg |pronget01.n<br />
				tuint921.stat = tdcpe.esta.error |pronget01.n<br />
				tuint921.fase = tucpe.fase.pro.vali |pronget01.n<br />
			else<br />
				report.msg = &quot;MENSAJE: Pedido &quot; &amp; strip$(shiftl$(str$(tuint921.orno))) &amp;<br />
				     &quot;/&quot; &amp; strip$(shiftl$(str$(tuint921.item))) &amp;<br />
				     &quot;, Linea O/V creada &quot; &amp;<br />
				     str$(ovta.orno) &amp; &quot;/&quot; &amp; str$(ovta.pono)<br />
				     &amp; &quot;/&quot; &amp; str$(ovta.sqnb)<br />
				if not isspace(error.msg) then<br />
					report.msg = report.msg &amp; &quot; : &quot; &amp; error.msg<br />
				endif<br />
				tuint921.merr = report.msg<br />
				tuint921.stfz = tuint.stad.success<br />
				tuint921.erro = &quot;&quot; |pronget01.n<br />
				tuint921.stat = tdcpe.esta.exito |pronget01.n<br />
				tuint921.fase = tucpe.fase.pro.ovtd |pronget01.n<br />
			endif<br />
			| NOVAGAC01.sn<br />
			|pronget02.sn<br />
			puntero_tuint921 = db.bind(&quot;ttuint921&quot;, buf.ttuint921)<br />
			db.columns.to.record(puntero_tuint921) <br />
			|pronget02.en<br />
			db.retry.point()<br />
			select tuint921.*<br />
			from tuint921 for update<br />
			where tuint921._index1 = {:tuint921.orno,:tuint921.nuli,:tuint921.item}<br />
			selectdo<br />
				if ok.error.lineas then<br />
					tuint921.merr = &quot;O/V : &quot; &amp; strip$(shiftl$(str$(ovta.orno))) &amp; error.msg<br />
					tuint921.stfz = tuint.stad.error<br />
					tuint921.erro = &quot;O/V : &quot; &amp; strip$(shiftl$(str$(ovta.orno))) &amp; error.msg |pronget01.n<br />
					tuint921.stat = tdcpe.esta.error |pronget01.n<br />
					tuint921.fase = tucpe.fase.pro.vali |pronget01.n<br />
				else<br />
					tuint921.merr = report.msg<br />
					tuint921.stfz = tuint.stad.success<br />
					tuint921.erro = &quot;&quot; |pronget01.n<br />
					tuint921.stat = tdcpe.esta.exito |pronget01.n<br />
					tuint921.fase = tucpe.fase.pro.ovtd |pronget01.n<br />
				endif<br />
 				val_retu = db.update(ttuint921, DB.RETRY)<br />
				val_retc = commit.transaction()<br />
			endselect<br />
			|pronget02.sn<br />
			db.record.to.columns(puntero_tuint921) <br />
			db.unbind(puntero_tuint921)<br />
			|pronget02.en<br />
<br />
			| NOVAGAC01.en<br />
		endselect<br />
		| NOVAGAC01.sn<br />
		| Cuando hubo existo en subir TODAS LAS LINEAS DEL PEDIDO<br />
		| Ahi actualizar el status de subida exitosamente en la cabecera<br />
		|pronget02.sn<br />
		puntero_tuint920 = db.bind(&quot;ttuint920&quot;, buf.ttuint920)<br />
		db.columns.to.record(puntero_tuint920) <br />
		|pronget02.en<br />
		db.retry.point()<br />
		select tuint920.*<br />
		from tuint920 for update<br />
		where tuint920._index2 = {:tuint920.orno} | NOVAGAC03.n<br />
		selectdo<br />
			if not ok.error.lineas then<br />
				tuint920.stfz = tuint.stad.success<br />
|pronget01.o				tuint920.stat = tdcpe.esta.exito |pronget01.n<br />
				|getsito<br />
			else<br />
				tuint920.stfz = tuint.stad.error<br />
|pronget01.o				tuint920.stat = tdcpe.esta.error |pronget01.n<br />
				|getsito<br />
			endif<br />
			tuint920.fech = utc.num() |pronget01.n<br />
			tuint920.user = logname$  |pronget01.n<br />
			val_retu = db.update(ttuint920, DB.RETRY)<br />
			val_retc = commit.transaction()<br />
		endselect<br />
		|pronget02.sn<br />
		db.record.to.columns(puntero_tuint920) <br />
		db.unbind(puntero_tuint920)<br />
		|pronget02.en<br />
		| NOVAGAC01.en<br />
	selecteos<br />
		COMMIT.transaction()<br />
		| Ejecutar procesamiento directo y actualizar cantidad entregada<br />
		stpapi.end.session(&quot;tdsls4501m000&quot;)<br />
		if ok.proceso then<br />
			report.msg = &quot;MENSAJE: Proceso completado con exito!&quot;<br />
		else<br />
			report.msg = &quot;ERROR: Se produjeron errores durante el proceso! Revise el archivo  &quot; &amp; strip$(que.errfile)<br />
		endif<br />
	selectempty<br />
		err.mesg = &quot;No existen Ordenes de Venta a Procesar&quot;  |pronget01.n<br />
	endselect<br />
<br />
	commit.transaction()<br />
	| Cerrar ventana de lista - ordenes de venta<br />
	stpapi.end.session(&quot;tdsls4500m000&quot;)<br />
|  	appl.delete(&quot;tuint1221m100&quot;&amp;str$(get.compnr())) |pronget02.n<br />
	actualiza.estado.ov()<br />
}<br />
<br />
<br />
function extern domain tcbool validar.ofbp(<br />
				    domain tccom.bpid ofbp,<br />
				ref domain tcmcs.str215 error.msg)<br />
{<br />
| 	table	ttccom100	|partners<br />
| 	table	ttccom110	|Clientes<br />
| 	table	ttccom111	|<br />
<br />
	domain	tcbool one.time.bp<br />
<br />
	| * Validar estatus inactivo<br />
	select	tccom100.*<br />
	from	tccom100<br />
	where	tccom100._index1 = { :ofbp }<br />
	selectdo<br />
		if tccom100.prst = tccom.prst.inactive then<br />
			error.msg = &quot;El partner &quot; &amp; ofbp &amp; &quot; tiene estatus &quot; &amp;<br />
				    enum.descr$(&quot;tccom.prst&quot;, tccom100.prst)<br />
			return(false)<br />
		endif<br />
	endselect<br />
<br />
	| * Validar partner cliente<br />
	select	tccom110.*<br />
	from	tccom110<br />
	where	tccom110._index1 = { :ofbp }<br />
	selectdo<br />
		if tccom110.bpst = tccom.prst.inactive then<br />
			error.msg = &quot;El partner cliente &quot; &amp; ofbp &amp; &quot; tiene estatus &quot; &amp;<br />
				    enum.descr$(&quot;tccom.prst&quot;, tccom110.bpst)<br />
			return(false)<br />
		endif<br />
	selectempty<br />
		error.msg = &quot;No se ha hallado partner cliente para partner &quot; &amp; ofbp<br />
		return(false)<br />
	endselect<br />
<br />
	| * Validar partner receptor<br />
	select	tccom111.*<br />
	from	tccom111<br />
	where	tccom111._index1 = { :ofbp }<br />
	selectdo<br />
		if tccom111.bpst = tccom.bpst.inactive then<br />
			error.msg = &quot;El partner receptor &quot; &amp; ofbp &amp; &quot; tiene estatus &quot; &amp;<br />
				    enum.descr$(&quot;tccom.bpst&quot;, tccom111.bpst)<br />
			return(false)<br />
		endif<br />
	selectempty<br />
		error.msg = &quot;No se ha hallado partner receptor para partner &quot; &amp; ofbp<br />
		return(false)<br />
	endselect<br />
<br />
	|* Check whether BP is potential<br />
	if tccom.dll4010.sold.to.potential(ofbp) then<br />
		error.msg = form.text$(&quot;tdsls41014&quot;)<br />
	   	|* Sales orders or sales contracts for prospects not allowed.<br />
	endif<br />
<br />
	|* below is needed because one time bp function return a true or a<br />
	|* false, but tools could also return negative values.<br />
	one.time.bp = (tccom.dll4000.one.time.business.partner(ofbp) =<br />
		       true ? true : false)<br />
	if one.time.bp then<br />
		if not(tccom.dll4014.pay.by.bp.present(ofbp)) or<br />
		   not(tccom.dll4012.invoice.to.bp.present(ofbp)) then<br />
			error.msg = form.text$(&quot;td4100.1&quot;)<br />
			error.msg = sprintf$(error.msg, ofbp)<br />
			|* Pay-by and Invoice-to Business Partners must be<br />
			|* defined for Business Partner %s.<br />
			return(false)<br />
		endif<br />
	endif<br />
<br />
	return(true)<br />
}<br />
<br />
function domain tcbool crear.cabecera.ovta(ref domain tcorno	   ovta.orno,<br />
					   ref domain tcmcs.str215 error.msg)<br />
{<br />
	|pronget02.sn<br />
	domain tccom.bpid q.bpid<br />
	domain tccotp	  q.sotp<br />
	domain tccotp	  q.sotp1<br />
	domain tcseri 	  q.seri<br />
	domain tccotp 	  q.sotd<br />
	domain tcseri 	  q.serd<br />
	domain tccdis     q.motv<br />
	domain tcemno     q.crep<br />
	domain tccwar 	  q.cwar<br />
	domain tcdate     q.ddat <br />
	domain tcdate     q.odat <br />
	domain tccwoc     x.cofc <br />
	domain tccwoc     y.cofc <br />
	domain tcorno     q.orno<br />
	domain tclong     q.secu<br />
	domain tcrefa     q.refa<br />
	|pronget02.en<br />
	<br />
	<br />
	ovta.orno = &quot;&quot;<br />
	error.msg = &quot;&quot;<br />
<br />
	| Sincronizar con sesion single<br />
	ret = stpapi.synchronize.dialog(&quot;tdsls4500m000&quot;, &quot;add&quot;, error.msg)<br />
	if not ret then<br />
		error.msg = &quot;Crear orden de venta. &quot; &amp;<br />
			    &quot;Sincronización con sesion tdsls4100s000: &quot; &amp; error.msg<br />
		stpapi.end.session(&quot;tdsls4500m000&quot;)<br />
		return(false)<br />
	endif<br />
<br />
	Select tuint100.*<br />
	from tuint100<br />
	where tuint100._index1 ={:empresa} | NOVAGAC03.n<br />
	as set with 1 rows      |dyr<br />
	selectdo<br />
	endselect<br />
<br />
	|pronget02.sn<br />
	q.bpid = tuint920.bpid<br />
	q.sotp = tuint920.sotp<br />
	q.sotp1 = tuint100.sotp<br />
	q.seri = tuint100.seri<br />
	q.sotd = tuint100.sotd<br />
	q.serd = tuint100.serd<br />
	q.motv = tuint100.motv<br />
	q.crep = tuint920.crep <br />
	q.cwar = tuint920.cwar <br />
	q.ddat = tuint920.ddat <br />
	q.odat = tuint920.odat <br />
	q.orno = tuint920.orno<br />
	q.secu = tuint920.secu<br />
	q.refa = tuint920.refa<br />
	|pronget02.en<br />
	<br />
	<br />
	| Llenar datos de cabecera de orden de venta<br />
	stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.ofbp&quot;, q.bpid)             |partner<br />
	if strip$(q.sotp)=&quot;VNO&quot; or  strip$(q.sotp)=&quot;VNI&quot; then<br />
		stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.sotp&quot;, q.sotp)          |tipo de orden de venta<br />
		stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.orno&quot;, q.seri)          |numero de la ovta<br />
	else<br />
		stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.sotp&quot;, q.sotd)             |tipo de orden de venta<br />
		stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.orno&quot;, q.serd)             |tipo de orden de venta<br />
		|Verificamos si es una VDI colocar el motivo de devolucion<br />
		stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.retr&quot;, strip$(q.motv))             |Motivo de Devolucion<br />
	endif<br />
	stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.crep&quot;, q.crep)             |vendedor<br />
	stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.cwar&quot;, q.cwar)             |Almacen<br />
	stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.ddat&quot;, str$(q.ddat))       |fecha planificada de entrega  |mjc.n<br />
	stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.odat&quot;, str$(q.odat))       |Fecha Orden<br />
	stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.refa&quot;, str$(q.refa))       |REferencia Orden PDA<br />
   <br />
	select tccom110.*<br />
	from tccom110<br />
	where tccom110._index1={:tuint920.bpid}   |dyr.n<br />
	selectdo<br />
		|pronget02.sn<br />
		x.cofc = tuint100.cofc<br />
		y.cofc = tccom110.cofc<br />
		|pronget02.en<br />
		if len(strip$(tccom110.cofc))=0 then<br />
			stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.cofc&quot;, str$(x.cofc))                  |Departamento de Ventas<br />
		else<br />
			stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.cofc&quot;, str$(y.cofc))                  |Departamento de Ventas<br />
		endif<br />
	endselect<br />
	| NOVAGAC01.sn<br />
	stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.corn&quot;, q.orno)<br />
	stpapi.put.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.refb&quot;, q.orno&amp;&quot; - &quot;&amp;str$(q.secu))<br />
	| NOVAGAC01.en<br />
	<br />
	| Grabar datos<br />
	<br />
	ret = stpapi.insert(&quot;tdsls4500m000&quot;, true, error.msg)<br />
		<br />
	<br />
	if not ret then<br />
		stpapi.recover(&quot;tdsls4100s000&quot;, recover.msg)<br />
		error.msg = &quot;Crear orden de venta. &quot; &amp;<br />
			    &quot;Guardar datos en sesion tdsls4100s000: &quot; &amp; error.msg<br />
		stpapi.end.session(&quot;tdsls4100s000&quot;)<br />
		stpapi.end.session(&quot;tdsls4500m000&quot;)<br />
		return(false)<br />
	endif<br />
	stpapi.enum.answer(&quot;tdsls4100s000&quot;,&quot;tdslss0065&quot;, tcyesno.yes)<br />
	stpapi.handle.subproc(&quot;tdsls4100s000&quot;,&quot;tdslss0065&quot;,&quot;ignore&quot;) |pronget02.n<br />
	stpapi.get.field(&quot;tdsls4100s000&quot;, &quot;tdsls400.orno&quot;, ovta.orno)<br />
	stpapi.end.session(&quot;tdsls4100s000&quot;)<br />
	stpapi.end.session(&quot;tdsls4500m000&quot;) | NOVAGAC01.n<br />
<br />
	return(true)<br />
}<br />
<br />
function domain tcbool ubicar.marcar.ovta(  domain tcorno	ovta.orno,<br />
					ref domain tcmcs.str215 error.msg)<br />
{<br />
	| Ubicar la orden de venta<br />
	stpapi.put.field(&quot;tdsls4500m000&quot;, &quot;tdsls400.orno&quot;, ovta.orno)<br />
	ret = stpapi.find(&quot;tdsls4500m000&quot;, error.msg)<br />
	if ret &lt;&gt; 1 then<br />
		error.msg = &quot;ERROR: No se pudo encontrar la orden de venta &quot; &amp;<br />
			     ovta.orno &amp; &quot; : &quot; &amp; error.msg<br />
		return(false)<br />
	endif<br />
<br />
	| Marcar registro para llamar sesion de detalle de transacciones<br />
	ret = stpapi.mark(&quot;tdsls4500m000&quot;, error.msg)<br />
	if not ret then<br />
		error.msg = &quot;ERROR: No se pudo seleccionar &quot; &amp;<br />
			    &quot;la orden de venta &quot; &amp; ovta.orno<br />
		return(false)<br />
	endif<br />
<br />
	return(true)<br />
}<br />
<br />
function domain tcbool crear.linea.ovta(domain tcorno	    ovta.orno,<br />
				    ref domain tcpono	    ovta.pono,<br />
				    ref domain tcpono	    ovta.sqnb,<br />
				    ref domain tcmcs.str215 error.msg)<br />
{<br />
	domain 	tcmcs.str10	aux.pono<br />
	domain	tcmcs.str10	aux.sqnb<br />
	<br />
	|pronget02.sn<br />
	domain tcitem q.item<br />
	domain tcqsl1 q.quap<br />
	domain tcorno q.orno1<br />
	domain tclong q.nuli <br />
	<br />
	<br />
	q.item = tuint921.item<br />
	q.quap = tuint921.quap<br />
	q.orno1 = tuint921.orno<br />
	q.nuli = tuint921.nuli<br />
	|pronget02.en<br />
<br />
	error.msg = &quot;&quot;<br />
	ovta.pono = 0<br />
	ovta.sqnb = 0<br />
<br />
	leer.datos.articulo(q.item)<br />
<br />
	| Ubicar orde. de venta<br />
	stpapi.put.field(&quot;tdsls4501m000&quot;, &quot;tdsls401.orno&quot;, ovta.orno)<br />
	ret = stpapi.change.view(&quot;tdsls4501m000&quot;, error.msg)<br />
	<br />
	if not isspace(error.msg) then  | NOVAGAC05.n <br />
		error.msg = &quot;No se encontró la orden &quot; &amp; ovta.orno &amp;<br />
			    &quot;: &quot; &amp; error.msg<br />
		return(false)<br />
	endif<br />
<br />
	| Sincronizar con sesion single tdsls4101s000 - Lineas de orden vta<br />
	ret = stpapi.synchronize.dialog(&quot;tdsls4501m000&quot;, &quot;add&quot;, error.msg)<br />
	if not ret then<br />
		error.msg = &quot;Crear linea orden vta. &quot; &amp;<br />
			    &quot;Sincronización con sesion tdsls4101s000: &quot; &amp; error.msg<br />
		return(false)<br />
	endif<br />
<br />
	| Llenar datos de linea de orden de venta<br />
| 	stpapi.put.field(&quot;tdsls4101s000&quot;, &quot;tdsls401.item.segment.1&quot;, tcibd001.item)  |pronget01.n SOLO PARA QUE FUNCIONE EN NOVATECH<br />
	stpapi.put.field(&quot;tdsls4101s000&quot;, &quot;tdsls401.item&quot;, q.item)<br />
	stpapi.handle.subproc(&quot;tdsls4101s000&quot;,&quot;tdsls11033&quot;,&quot;ignore&quot;)<br />
	stpapi.put.field(&quot;tdsls4101s000&quot;, &quot;tdsls401.oqua&quot;, str$(q.quap))<br />
<br />
	|Enviamos Kill al mensaje de Stock<br />
|pronget02.o 	stpapi.handle.subproc(&quot;tdsls4101s000&quot;,&quot;tdsls4811s000&quot;,&quot;kill&quot;)<br />
	| NOVAGAC01.sn<br />
	stpapi.put.field(&quot;tdsls4101s000&quot;, &quot;tdsls401.corn&quot;, q.orno1)<br />
	stpapi.put.field(&quot;tdsls4101s000&quot;, &quot;tdsls400.corp&quot;, str$(q.nuli))<br />
	| NOVAGAC01.en<br />
	| Grabar datos<br />
	stpapi.handle.subproc(&quot;tdsls4101s000&quot;,&quot;00009057&quot;,&quot;ignore&quot;)<br />
	stpapi.handle.subproc(&quot;tdsls4101s000&quot;,&quot;tdsls4811s000&quot;,&quot;kill&quot;)<br />
	<br />
	ret = stpapi.insert(&quot;tdsls4501m000&quot;, true, error.msg)<br />
	<br />
	<br />
	if not ret then<br />
		stpapi.recover(&quot;tdsls4101s000&quot;, recover.msg)<br />
		error.msg = &quot;Sesión tdsls4101s000: &quot; &amp; error.msg<br />
		stpapi.end.session(&quot;tdsls4101s000&quot;)<br />
		stpapi.end.session(&quot;tdsls4501m000&quot;)<br />
		return(false)<br />
	endif<br />
<br />
	stpapi.get.field(&quot;tdsls4101s000&quot;, &quot;tdsls401.pono&quot;, aux.pono)<br />
	stpapi.get.field(&quot;tdsls4101s000&quot;, &quot;tdsls401.sqnb&quot;, aux.sqnb)<br />
<br />
	ovta.pono = lval(aux.pono)<br />
	ovta.sqnb = lval(aux.sqnb)<br />
<br />
	stpapi.end.session(&quot;tdsls4101s000&quot;)<br />
<br />
	return(true)<br />
}<br />
<br />
function leer.parametros()<br />
{<br />
	select	tuint100.*<br />
	from	tuint100<br />
	where tuint100._index1 ={:empresa} | NOVAGAC03.n<br />
	as set with 1 rows   |dyr.n<br />
	selectempty<br />
|pronget01.o 		message(&quot;No existen parametros de Fuerzas de Ventas&quot;)<br />
	err.mesg = err.mesg &amp; &quot; |No existen parametros de Fuerzas de Ventas&quot;<br />
	end()<br />
	endselect<br />
}<br />
<br />
function leer.datos.articulo(domain tcitem item)<br />
{<br />
	| Leer datos de artículo en base a clave de acceso II  y regresa<br />
	| el codigo del articulo<br />
	select	tcibd001.*<br />
	from	tcibd001<br />
	where tcibd001._index1={:item}    |dyr.n<br />
	selectdo<br />
	endselect<br />
}<br />
<br />
function actualiza.estado.ov()<br />
{<br />
	domain tcbool ok.error | NOVAGAC01.n<br />
	domain tcbool ok.paso  |pronget02.n<br />
	<br />
	ok.paso = false |pronget02.n<br />
	<br />
	db.retry.point()<br />
	select	tuint920.*<br />
	from	tuint920 for update<br />
	where  tuint920._index1 inrange {:secu.f} and {:secu.t}  |pronget01.n<br />
	order by tuint920._index1          |dyr.n<br />
	selectdo<br />
		ok.error = false | NOVAGAC01.n<br />
		select	tuint921.*<br />
		from	tuint921<br />
		where	tuint921._index1 = { :tuint920.orno }<br />
		and	tuint921.stfz = tuint.stad.error<br />
		as set with 1 rows | NOVAGAC01.n<br />
		selectdo<br />
			ok.error = true | NOVAGAC01.n<br />
			tuint920.stfz = tuint.stad.error       |dyr1.n<br />
			tuint920.stat = tdcpe.esta.error			|pronget01.n<br />
			tuint920.erro = &quot;Algunas líneas en error&quot;			|pronget01.n<br />
 			val_retu = db.update(ttuint920, DB.RETRY)		   |pronget02.n<br />
			val_retc = commit.transaction() |pronget02.n<br />
		selectempty<br />
			ok.paso = true |pronget02.n<br />
			tuint920.stat = tdcpe.esta.exito<br />
			val_retu = db.update(ttuint920,DB.RETRY) |pronget02.n		<br />
			val_retc = commit.transaction() |pronget02.n<br />
		|pronget01.en<br />
		endselect<br />
		| NOVAGAC01.sn<br />
|pronget02.o 		if not ok.error then<br />
 		if not ok.error and ok.paso then  |pronget02.o<br />
			| Verificar si tiene lineas en status libre<br />
			|pronget02.sn<br />
			puntero_tuint920 = db.bind(&quot;ttuint920&quot;, buf.ttuint920)<br />
			db.columns.to.record(puntero_tuint920) <br />
			db.retry.point()<br />
			select	tuint920.*<br />
			from	tuint920 for update<br />
			where   tuint920._index1 = { :tuint920.secu }  |pronget01.n<br />
			order by tuint920._index1          |dyr.n<br />
			selectdo<br />
			|pronget02.en<br />
				select	tuint921.*<br />
				from	tuint921<br />
				where	tuint921._index1 = { :tuint920.orno }<br />
				and	tuint921.stfz = tuint.stad.free<br />
				as set with 1 rows | NOVAGAC01.n<br />
				selectdo<br />
					| Hay lineas libres no debe cambiar status de<br />
					| Cabecera<br />
				selectempty<br />
					| NO hay lineas con error ni libres<br />
					| Debe poner en exitosa la cabecera<br />
					tuint920.stfz = tuint.stad.success<br />
					tuint920.stat = tdcpe.esta.exito  |pronget01.n<br />
					db.update(ttuint920, DB.RETRY)   |pronget02.n<br />
					val_retc = commit.transaction() |pronget02.n<br />
				endselect<br />
			endselect |pronget02.n<br />
			|pronget02.sn<br />
			db.record.to.columns(puntero_tuint920) <br />
			db.unbind(puntero_tuint920)<br />
			|pronget02.en<br />
		endif<br />
		| NOVAGAC01.en<br />
	endselect<br />
|pronget02.o 	commit.transaction()<br />
}<br />
<br />
|pronget01.sn<br />
function validar.existencia.det_new()<br />
{<br />
	db.retry.point()<br />
	select	tuint920.*<br />
	from	tuint920 for update<br />
	where  tuint920._index1 inrange {:secu.f} and {:secu.t}<br />
	and    tuint920.stfz = tuint.stad.free<br />
|pronget01.o	and    tuint920.stat = tdcpe.esta.libre<br />
	and    tuint920.fase = tucpe.fase.pro.vali<br />
	selectdo<br />
		select	tuint921.*<br />
		from	tuint921<br />
		where	tuint921._index1 = { :tuint920.orno }<br />
		order by tuint921.orno,tuint921.nuli<br />
		selectdo<br />
		selectempty<br />
			report.msg = &quot;ERROR: Orden PDA: &quot; &amp; shiftl$(shiftr$(tuint920.orno)) &amp; &quot; - &quot; &amp; &quot;No existen lineas de detalle&quot;<br />
			tuint920.merr = report.msg<br />
			tuint920.erro = report.msg<br />
			tuint920.stfz = tuint.stad.error<br />
|pronget01.o			tuint920.stat = tdcpe.esta.error |aqui estaba libre<br />
			|getsito<br />
			tuint920.fase = tucpe.fase.pro.subi<br />
 			val_retu = db.update(ttuint920, DB.RETRY)   |pronget02.n<br />
			val_retc = commit.transaction() |pronget02.n<br />
		endselect<br />
	endselect<br />
|pronget02.o 	commit.transaction()<br />
}<br />
|pronget01.sn<br />
<br />
<br />
function revisa.bloqueo.aplicacion()<br />
{<br />
	domain tcmcs.str70 que.clave <br />
<br />
	table tttadv998 <br />
	<br />
	| revisas si hay un bloqueo para ovta.orno <br />
	| Si hay algun bloqueo eliminarlo automáticamente.<br />
	db.retry.point()<br />
	que.clave = &quot;tdsls400&quot;&amp; strip$(ovta.orno)<br />
	select ttadv998.*<br />
	from  ttadv998 for update  <br />
	where ttadv998._compnr = 000 <br />
	  and ttadv998._index1 = {:que.clave}<br />
	selectdo<br />
			db.delete(tttadv998,db.retry)<br />
	endselect<br />
	commit.transaction()<br />
	<br />
}<br />
| NOVAGAC04.en<br />
|pronget01.sn<br />
function domain tcbool verifica.compania()<br />
{<br />
	<br />
	domain tcmcs.long que.compania, que.resultado<br />
	domain tcbool que.valor<br />
	<br />
	que.compania = get.compnr()<br />
	<br />
	if que.compania&lt;&gt;0 then		<br />
		que.resultado = switch.to.company(0)<br />
	endif<br />
	<br />
	que.valor = false<br />
	<br />
	select ttaad100.*<br />
	from   ttaad100<br />
	where  ttaad100._index1 = {:ncmp.f}<br />
	selectdo<br />
		que.valor = true<br />
	endselect<br />
	<br />
	que.resultado = switch.to.company(que.compania)<br />
	<br />
	return(que.valor)<br />
}<br />
<br />
function actualiza.detalles.a.error(domain tcmcs.str8 que.indica)<br />
{<br />
	select tuint921.*<br />
	from   tuint921 for update<br />
	where  tuint921._index1 = {:tuint920.orno}<br />
	selectdo<br />
		tuint921.stfz = tuint.stad.error<br />
		tuint921.stat = tdcpe.esta.error<br />
		if strip$(que.indica)=&quot;cabecera&quot; then<br />
			tuint921.erro = &quot;No se pudo crear cabecera&quot;<br />
		else<br />
			tuint921.erro = &quot;Cabecera no paso validaciones&quot;<br />
		endif<br />
		val_retu = db.update(ttuint921, DB.RETRY)	<br />
		val_retc = commit.transaction()<br />
	endselect<br />
|pronget02.o 	commit.transaction()<br />
}<br />
|pronget01.en</div></div><hr />


<div class="post"><div class="posttop"><div class="username">mark_h</div><div class="date">9th October 2008, 17:51</div></div><div class="posttext">Well the AFS code looks fine from what I can see.  What I was really thinking when I said source code - was the source code of the session itself.  For example in my case the Delete GRP production orders will error out every so often.  If I had the source for deleting GRP order I might be able to trace it to the code causing the problems.  As it is we just keep re-running them until all the orders are deleted.</div></div><hr />



</div>
</body>
</html>