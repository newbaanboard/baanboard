<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="keywords" content="Unicode character parsing in baan Ln, baan,baanerp,erp,forum,discussion,bulletin board" />
	<meta name="description" content="[Archive] Unicode character parsing in baan Ln Tools Development" />
	
	<title>Unicode character parsing in baan Ln [Archive]  - Baanboard.com</title>
	<link rel="stylesheet" type="text/css" href="../styles.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar"><a href="../index.html">Newbaanboard</a> &gt; <a href="../index.html">Baan Quick Support: Functional &amp; Technical</a> &gt; <a href="../index.html">Tools Development</a> &gt; Unicode character parsing in baan Ln</div>
<hr />
<div class="pda"></div>

<hr />

<div class="post"><div class="posttop"><div class="username">cyrilchacko</div><div class="date">4th September 2012, 11:46</div></div><div class="posttext">Hi,<br />
<br />
I am currently trying to read an UTF-16 file generated by another application. I am using the standard call for seq.gets to do this. This is then converted to the TSS format using uni.import function with the valid flag. Then it is read in to the variables and stored in the table.<br />
<br />
Now, while reading a unicode character (上), the seq.gets reads the 4 byte word (0x4E0A) erroneously as 2 byte word (0x0A) and assumes it to be the new line character. It therefore, stops reading further. It then reads the next character as part of the new line. Thus giving an error.<br />
<br />
Has someone encountered this and is there a solution or workaround?<br />
<br />
Thanks in advance.<br />
<br />
Regards,<br />
<br />
Cyril Parathazham</div></div><hr />


<div class="post"><div class="posttop"><div class="username">bdittmar</div><div class="date">4th September 2012, 12:42</div></div><div class="posttext">Hi,<br />
<br />
I am currently trying to read an UTF-16 file generated by another application. I am using the standard call for seq.gets to do this. This is then converted to the TSS format using uni.import function with the valid flag. Then it is read in to the variables and stored in the table.<br />
<br />
Now, while reading a unicode character (上), the seq.gets reads the 4 byte word (0x4E0A) erroneously as 2 byte word (0x0A) and assumes it to be the new line character. It therefore, stops reading further. It then reads the next character as part of the new line. Thus giving an error.<br />
<br />
Has someone encountered this and is there a solution or workaround?<br />
<br />
Thanks in advance.<br />
<br />
Regards,<br />
<br />
Cyril Parathazham<br />
<br />
Hello,<br />
from LN progguide :<br />
<br />
uni.import()<br />
Syntax:<br />
<br />
function long  uni.import  (ref string target$, const string source$ [, long sb_flag])<br />
<br />
Description<br />
<br />
<br />
This function converts a string from Unicode (encoded according to a UTF-16 Encoding encoding scheme) to the TSS Encoding character set. The default encoding scheme is UTF-16BE, i.e. each UTF-16 code unit is assumed to be serialized with the most significant byte first.<br />
<br />
<br />
Arguments<br />
<br />
ref string target$ The target string. This string will receive the TSS encoded characters. This can be a maximum of 4096 bytes.<br />
 <br />
const string source$ The source string. It is assumed to be in byte serialized UTF-16 encoding.<br />
 <br />
[long sb_flag ] This optional specifies the byte-order of the source string. Default is UNI_MSB_ORDER.<br />
<br />
UNI_DEF_ORDER Use the default byte order of the underlying Operating System. <br />
UNI_MSB_ORDER De-serialize the UTF-16 code units with the most significant byte first, i.e. use UTF-16BE. <br />
UNI_LSB_ORDER De-serialize the UTF-16 code units with the least significant byte first, i.e. use UTF-16LE. <br />
 <br />
This optional specifies the byte-order of the source string. Default is UNI_MSB_ORDER.<br />
<br />
UNI_DEF_ORDER Use the default byte order of the underlying Operating System. <br />
UNI_MSB_ORDER De-serialize the UTF-16 code units with the most significant byte first, i.e. use UTF-16BE. <br />
UNI_LSB_ORDER De-serialize the UTF-16 code units with the least significant byte first, i.e. use UTF-16LE. <br />
 <br />
 <br />
 <br />
Return values<br />
<br />
\u2265 0       the number of converted bytes<br />
<br />
  -1       the target string was too small to contain the converted string<br />
<br />
  -2       an incomplete character was found at the end of the string<br />
<br />
  -3       character could not be converted.<br />
<br />
Context<br />
<br />
This function can be used in all script types.<br />
<br />
Related topics <br />
<br />
Inverse operation: uni.export()<br />
TSS Encoding<br />
Unicode<br />
UTF-16 Encoding<br />
Multibyte strings overview and synopsis<br />
<br />
Regards</div></div><hr />


<div class="post"><div class="posttop"><div class="username">cyrilchacko</div><div class="date">5th September 2012, 06:37</div></div><div class="posttext">Hi,<br />
<br />
I am currently using uni.import to do the UTF extraction and the character encoding is in UTF-16-LE with CRLF line ending. I am quoting the line below.<br />
<br />
8T190XXX||3|XXX|XXXX00218003|XXX10|||XXXX21||||XXXX.XX|D||||上海网络维护<br />
<br />
The only part that is in chinese is the last block. The character &quot;上&quot; has the hex value 0x4E0A. Somehow this is read by the seq.gets call as a line break. When the file was in LSB mode the value retrieved was &quot;\n&quot; or 0x0A and then the remaining in the next call of seq.gets. In MSB the character is read as 0x4E and then &quot;\n&quot; or 0x0A.<br />
<br />
It is not the uni.import that is failing in my case, but the seq.gets. Is there a way to read a line of import that reads the character as 0x0A4E as it is in the UTF-16LE mode?<br />
<br />
I do have seq.read, but it does not recognize end of line at all. So, I am a bit stuck with this.<br />
<br />
Regards,<br />
<br />
Cyril Parathazham</div></div><hr />


<div class="post"><div class="posttop"><div class="username">mark_h</div><div class="date">5th September 2012, 15:31</div></div><div class="posttext">Can you use seq.gets to read one character or byte, at a time?  Or maybe seq.read.  I was thinking build your input string until you got to the real EOL.  Not sure if your input will be consistent enough to tell this.  Not sure if this will work or not.</div></div><hr />



</div>
</body>
</html>